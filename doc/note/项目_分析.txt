客户端
	引擎
		使用Unity
        动画系统
        粒子系统
        光照系统
        音效系统
        时间线
	脚本
		使用Tolua,框架原理分析如下
		lua源码分析
            lmem 定义了几个内存分配函数
            lstring 定义了创建和获取字符串大小的函数
            ltable 定义了几个辅助获取设置遍历table的函数
            lapi定义了基础函数lua_push/to* index2addr type typename 等等
            ldebug定义了几个err函数
            lfunc定义了函数的创建删除操作
            ldo定义了函数调用函数
            类型定义 lightuserdata是一个纯粹的指针,userdata是一个C#或者C++类对象,在lua内有相关元表
                lobject.h 基本类型结构定义
                    lua_TValue包含一个联合类型Value和一个整数tt代表当前对象类型
                        Value内包括GCObject引用类型 lua_Number浮点双精度类型 int整型 p指针lightuserdata类型
                        该结构包含对应的一组ttis* *value set*value 函数作为其成员函数
                    lua_TString包含一个联合类型dummy用于字节对齐,一个结构体存储真正的字符串
                        CommonHeader用于标记GC对象 next tt mark
                        reserved标记当前字符串是第几个保留字
                        hash标记当前字符串哈希码
                        len标记使用长度
                        sizeof(ts)+1 是字符串起始地址
                        getstr svalue用于获取字符串
                    Udata包含一个联合类型dummy用于字节对齐,一个结构体存储真正的数据
                        CommonHeader用于标记GC对象 next tt mark
                        metatable标记元表
                        env标记环境
                        len标记长度
                    Proto定义了函数原型
                        CommonHeader用于标记GC对象 next tt mark maxstacksize定义了函数栈大小 upvalues存储了upvalue的名字 source标记upvalue来源
                        Instruction*code定义指令集合 Proto**p定义局部函数 LocVar定义了函数内部变量 TValue定义了内部常量
                        lineinfo是指令到源代码行数的映射 size*定义了各个数组的长度 nups numparams定义了upvalue个数和参数个数
                    LocVar UpVar双向链表存储
                    Cloure 对proto的封装,一个闭合函数包括函数原型和upvalues isC nupvalues gclist env
                    TKey是一个联合类型,可以是一个值也可以是一个链表
                    Table CommonHeader用于标记GC对象 next tt mark lsizenode标记node数组长度 sizearray标记数组长度
                        metatable元表 array数组 node链表 lastfree gclist
                lstate.h 基本类型组合 定义了一系列gc2*获取对应类型变量
                    global_State包含str池 mem变量组 gc变量组 注册表 mainLuaState 基本类型元表
                    lua_State CommonHeader用于标记GC对象 top/base标记栈顶栈底 l_G全局状态 
                        CallInfo当前调用函数信息,包含base/top标记当前函数的栈顶栈底 nresults标记返回值个数 ntails标记尾调用个数,savedpc标记当前函数执行到的指令
                        savedpc标记当前执行到的指令
                        stack 标记栈底 栈大小 栈可用位置
                        hook 标记钩子个数 钩子数组 钩子开关 
                        l_gt全局表  openupvalues
                        errjmp errfunc标记错误跳转点和错误处理函数 
                    GCObject是lobject几种引用类型的组合,联合类型
                ltm.h 元表定义
                    定义了基础的元表__gc __index __newindex等元表的枚举,定义了获取基本元表的函数
                    内部用过传入的变量类型switch元函数,回去全局表的元表数组里获取对应的元表
                    init函数在全局表内定义了基本类型的元表
            指令字节码 lopcodes
                每条指令的字节码构成 操作码(6位) 操作数A(9位) B(9位) C(9位) Bx(18位) sBx(有符号数)
                OP_MOVE OP_ADD OP_SUB OP_FOR OP_NEWTABLE OP_CALL OP_TAILCALL等等38种指令
            词法分析/语法分析 代码生成 llex lparser lcode         
            垃圾回收 lgc
            虚拟机 lvm,定义了execute函数执行指令死循环直到所有指令全部执行完毕
            require过程:
                栈顶参数为filepath
                首先从注册表内取出_LOADED表,如果以filepath为key取到一个bool值,说明该文件加载过,返回该bool值
                从当前函数环境表内获取loaders表,一般是从注册表的loaders里获取,找一个可用的loader,加载完文件使用lua_loadbuffer编译该文件
                对_LOADED表以filepath为key设置固定的lightuserdata sentinel
                调用编译后的chunk函数,以filepath作为参数,如果函数内使用了module,module的输入参数是...则为filepath,否则为自定义字符串
                调用后_LOADED表内存储了module函数的设置结果,如果是自定义字符串,那么filepath对应的值没有设置过
                如果函数有返回值且非空,则设置_LOADED表filepath做key等于该返回值
                如果_LOADED表filepath为key等于sentinel,则设置为bool值true,标记该文件加载过但是没有设置filepath的全局变量
            load过程:
                luaL_loadbuffer->lua_load->luaD_protectedparser->luaD_pcall(会传入当前栈顶用于错误恢复)->f_parser->luaY_parser
                luaX_next读取第一个token->chunk函数解析->close_func设置Proto并将其移除栈顶
                创建LoadS结构体并初始化
                创建ZIO结构体并初始化
                创建Sparser结构体并初始化
                读取第一个字符,如果是LUA_SIGNATURE则输入是字节码调用lua_undump,否则是源码调用luaY_parser
                创建LexState、FuncState结构体并初始化,新建Proto,栈顶压入upvalue表、proto函数原型两个变量
                调用chunk循环分析token,每个token定于不同的控制结构 for repeat while function 等等
                解析结果是一个函数,upvalue是其中使用的全局变量个数,调用luaF_newLclosure创建一个闭合函数
                将最终创建的闭合函数压入栈顶setclvalue(L,L->top,cl)
            newstate过程:
		ToLua源码分析
	数据
		使用protobuf,框架原理分析如下
	界面
		使用NGUI,框架及问题分析
            NGUI源码分析
                事件系统
                    
            UIDrawCall
                所有UI组件都是创建了一个隐藏的GameObject,并添加了UIDrawCall组件、MeshFilter组件、MeshRenderer组件
                每个UIDrawCall会创建一个MESH和一个材质并赋值给MeshFilter和MeshRenderer
                UI组件更新过程 panel.LateUpdate->UpdateSelf->UpdateWidgets->UpdateGemotry->UpdateDrawCall
                UpdateGemotry之后会进行坐标系变换,把UI组件变换到UIPanel根结点下panel.worldToLocal * trans.localToWorld
            UIAtals UIFont
                UISprite和UILabel使用的材质排序后相邻的如果相同
                unity会做动态批处理合并MESH
            裁剪
                clipSoftness.xy,虚边界大小
                clipRange.xyzw,裁剪区域中心及大小
                shader内_clipRange = (-px/z,-py/w,1/z,1/w) clipArg = (z/sx,w/sy)
                前提条件,Panel在摄像机坐标系下没有偏移
                1.计算顶点坐标在Panel内到中心的距离(归一化为0到1的值),o.worldPos = (vx-px)/z,(vy-py)/w = v.vertex * _clipRange.zw + _clipRange.xy
                  o.worldPos绝对值大于1则处于Panel外面,小于1在Panel内部
                2.计算顶点坐标在Panel内到边界的距离(归一化为0到1的值),o.distance = (z,w)-abs(vx-px,vy-py)
                  该距离和虚边界大小比值可用于计算像素点alpha值 clamp(min(o.distance.xy/s.xy),0,1)
                  算出最终表达式为 factor = [(z,w)-abs(vx-px,vy-py)]/(sx,sy)=[(1,1)-abs((vx-px)/z,(vy-py)/w)] * (z/sx,w/sy) = [(1,1) - abs(o.worldPos)] * clipArg;
                  a = clamp(min(factor.x,factor.y),0,1)
                3.整理上述过程得出
                  1.设置裁剪参数_clipRange=-px/z,-py/w,1/z,1/w) _clipArg=(z/sx,w/sy)
                  2.顶点着色器内计算顶点坐标 o.worldPos = o.vertex * _clipRange.zw + _clipRange.xy
                  3.像素着色器内计算alpha值 factor = [(1,1) - abs(o.worldPos)] * _clipArg; a = clamp(min(factor.x,factor.y),0,1)
            透明度
                通过父结点alpha值控制子物体显示,有坑如下
                UI组件显示时会计算父物体alpha值,父物体是在OnEnable之后做了缓存
                如果在OnEnable之后修改了父结点,alpha计算就会出现BUG(新父结点alpha为0不生效)
                UpdateGeometry->CalculateFinalAlpha->UpdateFinalAlpha->parent.CalculateFinalAlpha
            自适应
                UI摄像机Camera.size为高度size,也就是高度为2
                屏幕真实宽高比为Screen.width:Screen.height
                自定义宽高:manualHeight manualWidth
                宽度自适应:宽度始终铺满屏幕,UI的真实高度activeHeight需要计算(manualWidth / aspect)
                          把像素高度为activeHeight的UI放入高度为2的摄像机内,需要缩放2/activeHeight倍数
                高度自适应:把像素高度为activeHeight = manualHeight的UI放入高度为2的摄像机内,需要缩放2/activeHeight倍数

                基准分辨率为16:9,宽高比超过该比例的需要高度自适应,小于等于该比例需要宽度自适应
                iPhoneX有一个安全区的概念,屏幕周边有一圈是无法点击的只能显示
            拖拽
                由于自适应操作UI的高度范围可能会缩放
                因此需要delta.y * (activeHeight / Screen.height)来计算真正的y偏移
服务器
  	Login: 
  		线程1,连接线程,管理与Client的连接,登录请求
		 	线程2,管理与WorldServer和第三方Server的连接,World的负载均衡,第三方SDK请求登录		        
     	线程C,管理与DB的连接,登录验证,token生成,角色列表
     	线程D,
     	线程E,主线程,守护子线程
  	Gate   网络消息转发,流量控制
  	World  中心服,场景负载均衡、全局服务
  	Scene  场景、战斗
  	DBCache数据缓存,数据写库、读取 
  	路由  中心服&单点服务&区组,消息转发 服务注册 