Tomcat  JAVA应用容器 负载均衡,反向代理
Nginx   负载均衡,反向代理
NodeJs  javascript语言,使用googleV8引擎来解释脚本,服务器框架pomelo

服务器软件是以系统服务的形式运行,守护进程监测其运行状态,异常时进行重启

HTTP网址参数 #位置 ?表示参数 &参数分隔符
			
单进程多线程非阻塞模式
			
TCP/IP协议栈
			应用层,自定义消息,序列化为字节数据,发给传输层,这一层是用户控制的,跟具体应用关系密切
				    HTTP传输使用Base64编码
			传输层,TCP UDP
			       把下层消息传递到上层进程
				   把上层进程的消息加入端口号后传给网络层
				   传递之前会有分组和合并的操作,确保消息完整
				   TCP流量控制  
				       TCP有一个接收缓冲区和发送缓冲区,三次握手时会通知其大小
					   TCP不能发送超出该缓冲的数据,缓冲区满了以后会返回给发送方一个WINDOW大小,代表可以接收的数据大小
					   TCP发送数据时,一次能够发送的数据有限
					   setsockopt(socket,SOL_SOCKET || IPPROTO_TCP || IPPROTO_IP,选项,值,值SIZE);
					   setsockopt(socket,SOL_SOCKET,SO_RCVBUF,&size,sizeof(UINT))   设置接收缓冲区大小
					   setsockopt(socket,SOL_SOCKET,SO_SNDBUF,&size,sizeof(UINT))   设置发送缓冲区大小
					   setsockopt(socket,SOL_SOCKET,SO_LINGER,linger,sizeof(linger))设置断开连接时是否丢弃未发送的数据 linger结构体 l_onoff l_linger
				       ping命令发包, -f数据不分段 -l设置发送缓冲区大小
					   WIN ioctlsocket(socket,FIONBIO,0 || 1) 设置socket是否阻塞
					   LIX fcntl(socket,F_GETFL,O_NONBLOCK)
				   TCP超时重传 socket发送数据后,收到接收方反馈确认数据被接收,否则超过一定时间重新发送,被接收之前数据会一直存放在缓冲区内
				       心跳包,定时发送心跳数据包,用来确定连接是否断开				   
			网络层,IP ARP&RARP
				   IP地址分为ABCDE五类,A类0-127 0三字节主机号 B类128-191 10两字节主机号 C类192-223 110一字节主机号 .0是网络地址 255是广播地址
				   IP地址由网络号+主机号构成
				   子网,子网掩码用于计算两个IP地址是否属于同一个网络,
				   IP地址与子网掩码做and运算,得出网络号
				   
				   首先计算 源IP与目的IP的网络号,相同则发送ARP请求包给子网内所有主机,目的IP主机收到后反馈RAP附带MAC地址,IP封包完成发送数据到子网内所有主机,MAC一致的主机接收IP包
												 不相同则发送ARP请求给网关,网关反馈MAC,收到后封包发给网关,网关收到后发给路由器,路由器经过路由选择算法一跳一跳的到达目标网络主机
												 提供服务的主机必须拥有公网IP才可以被访问
												 
												 内网机器需要设置路由端口映射,把对外网IP某个端口映射到本地主机的进程
				                                  
			接口层,
			
网络进程
	 socket 头文件 sys/socket.h 包含socket bind listen recv recvfrom send sendto
			头文件 arpa/inet.h  包含htons htonl ntohs ntohl inet_addr inet_ntoa inet_ntop inet_pton  端口号字节序转换,IP字节序转换
			头文件 netinet/in.h 包含sockaddr_in结构
			头文件 fcntl.h      包含fcntl设置阻塞
			windows下只需要包含winsock2.h即可
	 服务器编程要考虑IO耗时和计算耗时	
SOCKET API 
	如果是在windows下,首先需要初始化SOCKET环境,  
		 WORD sockVersion = MAKEWORD(2,2);
		 WSADATA wsaData;
		if(WSAStartup(sockVersion, &wsaData)!=0)
		{
			return 0;
		}
	socket()：创建socket
			int socket(int domain, int type, int protocol);  
			AF_INET(ipv4) AF_INET6(ipv6)  
			SOCK_STREAM(面向连接流式数据) SOCK_DGRAM(无连接数据报) 
			IPPROTO_TCP IPPROTO_UDP
			创建错误返回INVALID_SOCKET
	bind()：绑定socket到本地地址和端口，通常由服务端调用
			sockaddr_in  .sin_family = AF_INET;
						 .sin_addr.s_addr = inet_addr(IP_ADDRESS);  inet_ntoa inet_addr
						 .sin_port = htons(PORT);  htons ntohs  字节序转换  头文件arpa/inet.h
			(sockaddr*)&addr
			创建错误返回SOCKET_ERROR
	listen()：TCP专用，开启监听模式
			TCP状态机从close转换为listen,第二个参数代表排队最多个数
			创建错误返回SOCKET_ERROR
	accept()：TCP专用，服务器等待客户端连接，一般是阻塞态
			阻塞调用,与bind参数一致,不过它的参数是传进去获取数据的
			accpet(server,(sockaddr)&addr,sizeof(sockaddr))
			创建错误返回INVALID_SOCKET
			accept只是从内核取出已完成三次握手的客户端SOCKET连接
	connect()：TCP专用，客户端主动连接服务器
			和bind用法一样,传入sockfd,sockaddr,sizeof(sockaddr),返回值-1表示出错
			创建错误返回SOCKET_ERROR
	send()：TCP专用，发送数据
			send(clientsocket,buff,size,0)
			发送和接收消息要给消息添加消息头,标识消息长度,需要一个消息缓冲区缓存接收到的数据
			发送错误返回SOCKET_ERROR,连接关闭返回0,成功返回1
	recv()：TCP专用，接收数据
			recv(clientsocket,buff,size,0)
			接收错误返回SOCKET_ERROR,连接关闭返回0,成功返回接收到的字节数
	sendto()：UDP专用，发送数据到指定的IP地址和端口
			比send多了两个参数,分别是server地址和地址大小
	recvfrom()：UDP专用，接收数据，返回数据远端的IP地址和端口

	closesocket(server)：关闭socket
	
	select
		  检测一组socket是否有数据到达
		  int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout) 
		  传入socket个数,socket读标记,socket写标记,socket异常标记,超时时间
		  fd_set fds;
		  FD_ZERO(&fds)清0  FD_SET(fd,&fds)置1  FD_ISSET(fd,&fds)是否置1 FD_CLR(fd,&fds)重置
		  客户端发送的connect操作,也会导致socket可读,所以select可以检测新的连接,所以FD_SET始终保持server socket句柄置为1
	连接上之后,服务器发送校验包,不通过则断开该链接
	select最大支持 FD_SETSIZE 个连接,也就是fd_set内的数组大小
	struct fd_set 
	{
			u_int fd_count;               /* how many are SET? */
			SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
	}
	
	select缺点是在链接数很多时用户与内核切换时的拷贝消耗,以及遍历消耗
	
epoll事件驱动
    select有连接数限制,最大2048
	select会有内存拷贝开销
	select连接数越多,遍历消耗越大,因为活跃的连接数占比较少
	  我们必须在select之后遍历描述符,找出标志位设为TRUE的那个,即轮询IO
	epoll没有连接限制
	epoll只通知我们哪个描述符发生了变化,也就是产生了事件,即事件驱动异步IO
	   返回epoll数组
	API
	   int handle = epoll_create(maxfds); 创建epoll文件
	   int ret = epoll_ctl(handle,op,fd,evt);     注册监听者  op可以是EPOLL_CTL_ADD EPOLL_CTL_MOD EPOLL_CTL_DEL 
	   epoll_event结构体表示事件,相关宏 EPOLLIN EPOLLOUT 可读可写事件 EPOLLERR 错误  EPOLLET  EPOLLLT
	   
		epoll_event ev;
		ev.data.fd=listenfd;
		ev.events=EPOLLIN|EPOLLET;	
	   int ret = epoll_wait(handle,events,max_count_perframe,-1);    等待事件发生
IOCP事件驱动
	创建IOCP对象 HANDLE hd = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
	绑定新连接到IOCP对象 HANDLE nd = CreateIoCompletionPort((HANDLE)n, hd, n, 0);   
	
	IOCP需要一个连接线程,多个IO线程,连接线程在接收连接后绑定客户socket到iocp对象
	IO读线程调用GetQueuedCompletionStatus()阻塞等待IO请求完成,处理完成调用异步WSARecv继续等待
	IO写线程
TCP连接与断开
	三次握手  client->send状态,发送syn请求连接
			  server收到syn请求,发送syn+ack,进入recv状态
			  client收到syn+ack,发送ack,进入establistened
			  server收到ack,进入establistened
	四次挥手
			  client发送fin请求断开连接,表示我不会再给你发数据了进入FIN_WAIT1
			  server收到fin请求,返回ack给client,表示我还有数据要发送,client进入FIN_WAIT2状态,server进入close_wait
			  server发送fin给client,告诉它我没有数据要发送了,server进入last_wait
			  client返回ack给server,进入TIME_WAIT,server收到ack进入closed,client等待Nms后进入closed
	协议栈
		应用(应用消息头+消息体)->TCP(TCP头+应用头+消息体)->IP(IP头+TCP头+应用头+消息体)->网卡
IO模型
  阻塞IO,阻塞在read、recv这样的系统调用上,也就是阻塞在当前socket的处理上
  非阻塞IO,需要设置socket为非阻塞io,unix使用fcntl的函数fcntl(fd,F_SETFL,O_NONBLOCK)
  IO多路复用,阻塞在select、epoll这样的系统调用上,这个函数是在任意socket有数据准备好就返回,而不是阻塞在一个socket上
  同步IO操作,请求导致进程阻塞,直到IO完成
  异步IO操作,请求不阻塞进程
  
  LINUX 文件映射
	mmap(0表示系统选择映射区起始地址,需要映射的字节数,PROT_READ | PROT_WRITE | PROT_EXEC,RESERVE | COMMIT,-1表示匿名新建文件,0);
	munmap(addr,len)释放文件
	
	共享内存
	shmget()
	shmat
	shmdt
	shmctl
  WINDOWS 文件映射
	  HANDLE handle = CreateFileMapping(0xFFFFFFFFFFFFFFFF,NULL,PAGE_READWRITE,sizeMax,sizeMin,mapKey)
	  HANDLE handle = OpenFileMapping(FILE_MAP_ALL_ACCESS,TRUE,mapKey)
	  void* ptr = MapViewOfFile(handle,FILE_MAP_ALL_ACCESS,0,0,0)
	  UnmapViewOfFile(ptr)
	  CloseHandle(handle)
	  
CDN多级缓存
	首先DNS服务器解析出目的地址,这个地址是CDN中心负载均衡服务器,负责把请求分散到区域最近的CDN服务器
	区域CDN负载均衡服务器根据用户IP地址选择最优的缓存服务器
	
HTTP协议 
		URL构成 协议://域名或者IP:端口/路径?数据k=v&k=v&k=v#锚
		无状态,就是两个请求之间没有关系
		协议构成
		        方法名(POST修改GET获取PUT上传DELETE删除) 资源地址 HTTP/版本