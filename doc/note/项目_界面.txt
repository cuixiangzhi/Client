NGUI源码分析
    事件系统
        UICamera
            ignoreAllEvents 所有NGUI事件的开关
            isOverUI 是否触摸到了NGUI组件
            hoveredObject 触摸对象
            currentTouch 当前触摸信息,包括lastPos&pos&delta
            currentTouchID 当前手指ID,-1表示左手,-2右手,-3滚轮
            CountInputSources() 触摸数量
            Update检测并转发事件
                优先检测Touch事件
                    通过引擎API获取触摸点个数,Input.touchCount
                    遍历每一个触摸结构体,Input.GetTouch(i),获取触摸状态、位置、个数、手指ID,更新对应的MouseOrTouch结构
                    TouchPhase.Began或者第一次创建该ID的touch则属于press状态,Cancel或者End属于unpress状态
                    遍历每一个UICamera,首先检测触摸点是否在视口内,并发射UI摄像机的cullingMask的射线
                    遍历碰撞到的N个对象,检查UIWidget或者UIRect组件,alpha值为0跳过检测

            LateUpdate检测屏幕大小变化并转发更新锚点事件
    输入管理

    渲染流程
    辅助工具
UIDrawCall
    所有UI组件都是创建了一个隐藏的GameObject,并添加了UIDrawCall组件、MeshFilter组件、MeshRenderer组件
    每个UIDrawCall会创建一个MESH和一个材质并赋值给MeshFilter和MeshRenderer
    UI组件更新过程 panel.LateUpdate->UpdateSelf->UpdateWidgets->UpdateGemotry->UpdateDrawCall
    UpdateGemotry之后会进行坐标系变换,把UI组件变换到UIPanel根结点下panel.worldToLocal * trans.localToWorld
UIAtals UIFont
    UISprite和UILabel使用的材质排序后相邻的如果相同
    unity会做动态批处理合并MESH
裁剪
    clipSoftness.xy,虚边界大小
    clipRange.xyzw,裁剪区域中心及大小
    shader内_clipRange = (-px/z,-py/w,1/z,1/w) clipArg = (z/sx,w/sy)
    前提条件,Panel在摄像机坐标系下没有偏移
    1.计算顶点坐标在Panel内到中心的距离(归一化为0到1的值),o.worldPos = (vx-px)/z,(vy-py)/w = v.vertex * _clipRange.zw + _clipRange.xy
      o.worldPos绝对值大于1则处于Panel外面,小于1在Panel内部
    2.计算顶点坐标在Panel内到边界的距离(归一化为0到1的值),o.distance = (z,w)-abs(vx-px,vy-py)
      该距离和虚边界大小比值可用于计算像素点alpha值 clamp(min(o.distance.xy/s.xy),0,1)
      算出最终表达式为 factor = [(z,w)-abs(vx-px,vy-py)]/(sx,sy)=[(1,1)-abs((vx-px)/z,(vy-py)/w)] * (z/sx,w/sy) = [(1,1) - abs(o.worldPos)] * clipArg;
      a = clamp(min(factor.x,factor.y),0,1)
    3.整理上述过程得出
      1.设置裁剪参数_clipRange=-px/z,-py/w,1/z,1/w) _clipArg=(z/sx,w/sy)
      2.顶点着色器内计算顶点坐标 o.worldPos = o.vertex * _clipRange.zw + _clipRange.xy
      3.像素着色器内计算alpha值 factor = [(1,1) - abs(o.worldPos)] * _clipArg; a = clamp(min(factor.x,factor.y),0,1)
透明度
    通过父结点alpha值控制子物体显示,有坑如下
    UI组件显示时会计算父物体alpha值,父物体是在OnEnable之后做了缓存
    如果在OnEnable之后修改了父结点,alpha计算就会出现BUG(新父结点alpha为0不生效)
    UpdateGeometry->CalculateFinalAlpha->UpdateFinalAlpha->parent.CalculateFinalAlpha
自适应
    UI摄像机Camera.size为高度size,也就是高度为2
    屏幕真实宽高比为Screen.width:Screen.height
    自定义宽高:manualHeight manualWidth
    宽度自适应:宽度始终铺满屏幕,UI的真实高度activeHeight需要计算(manualWidth / aspect)
              把像素高度为activeHeight的UI放入高度为2的摄像机内,需要缩放2/activeHeight倍数
    高度自适应:把像素高度为activeHeight = manualHeight的UI放入高度为2的摄像机内,需要缩放2/activeHeight倍数

    基准分辨率为16:9,宽高比超过该比例的需要高度自适应,小于等于该比例需要宽度自适应
    iPhoneX有一个安全区的概念,屏幕周边有一圈是无法点击的只能显示
拖拽
    由于自适应操作UI的高度范围可能会缩放
    因此需要delta.y * (activeHeight / Screen.height)来计算真正的y偏移