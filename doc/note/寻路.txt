路点寻路
    优点:快速实现,简单,路径顺眼
    缺点:无法动态规避障碍、无法标记角色信息、无法标记地形信息、路径不平滑
导航寻路
    生成导航网格 
        概念
            高度场(HeightField) 根据cell(一般为0.2,0.2,0.2)大小在xyz三个方向切割,由体素构成的对象
            体素(Span) 三维空间的像素
            开放区间(CompactSpan) 垂直方向一列相邻实心体素的集合
            闭合区间(CompactCell) 垂直方向一列相邻空心体素的集合
            压缩的高度场(CompactHeightfield) 由开放区间和闭合区间构成
            层级的高度场(HeightfieldLayerSet)
            轮廓
            凸多边形
            细节多边形
        实现
            加载网格信息,每行不是v就是f,v代表一个顶点,f代表三角形,针对每个三角形创建AABB包围盒,然后创建二叉搜索树
            初始化配置信息,角色半径、CELL大小、可行走角度、可跨越高度,计算出有多少体素
            创建高度场,仅包含空的span数组,体素个数即XZ大小和AABB
            创建可行走标记数组,遍历所有的三角形,根据可行走角度以及法线,标记可行走的三角形
            光栅化 计算三角形AABB
                   在xz平面切割三角形(切割过程新增切割点),y方向是连续的,切割后是一个实心体素集(Span)
                   检查当前列是否有Span,如果有就合并,合并时根据Climp大小标记区域可行走性质
            过滤可行走体素 根据角色脚步来过滤y方向(此时不能保证相邻的体素限制角色高度)
            过滤可行走体素 根据角色脚步和角色高度来过滤xz方向
            过滤可行走体素 根据角色半径来过滤无法站立的地方
            创建压缩的高度场 压缩到XZ平面,CompactCell为压缩后的数据,CompactSpan为压缩后的Span
            过滤可行走体素 根据体素距离边界的最小距离和角色半径*2比较,水平相邻距离为2,斜对角为3,离边界越远距离越大
                           默认格子大小为0.3(1倍距离),角色半径为0.6(2倍距离),默认判断2*2距离才可以站立
            区域分割       根据最大最小面积合并相邻的Span(标记为相同的region),并对相邻区域建立连接
            区域描边       根据分割好的区域找出边缘体素集合,然后根据最大边长和误差简化边缘
                           合并一些相邻的轮廓边
            生成多边形     根据描边集合和多边形顶点数限制生成凸多边形
            生成细节多边形 根据体素高度信息生成凸多边形的三角形集合
            标记区域特点   根据多边形区域ID标记区域是
    构造导航网格
        NavMesh由凸多边形、凸多边形三角形、OffMesh、tileLink、bvtree等构成,polyRef由tileID和polyID共同构成
    导航网格寻路
        寻找最近的多边形
            遍历所有的多边形,判断点是否在多边形内部(pnpoly算法)并计算与每条边的距离
            点在多边形内部则计算其高度,利用向量加法AP = u * AB + v * BC)
            不在多边形内部则返回目标点
        启发式搜索算法A*
            F = G + H
            算法简述:压入初始结点
                     循环
                        弹出第一个结点
                        遍历当前结点所有相邻结点
                            计算其COST,和当前结点比较,
                            旧结点且消耗更小或者是新结点,修改消耗及其父结点,已在OPEN表则修改其消耗,否则将其加入OPEN表
                            和当前结点比较,修改最优结点
            首先根据当前位置找出所在多边形A,目标位置所在多边形B(这里的多边形都是可行走的,不可行走的在生成阶段已被剔除)
                创建目标包围盒
                根据bmin和bmax获取所属tile位置
                根据tile位置获取tile,
                根据tile获取tile内多边形的包围盒(包围盒数组是一个排好序的数组,负数代表包围盒右子节点的偏移)
                根据包围盒二分树判断是否包含目标包围盒并且是叶节点
                根据找出来的多边形和目标位置,找出一个距离目标多边形最近的点或者包含在多边形内
            检查AB是否合法,AB是否相等,相等则直接返回A多边形引用,路径长度为1
            OPEN表清空
            新建NODE FOR A,消耗为0,H值为直线距离乘以缩放因子(控制是否找出最优路径,小于0一定是最优的),加入OPEN表
            循环(OPEN表非空)                 
                取头结点,更改结点状态为CLOSED,不修改父结点状态,是目标?结束循环:继续
                取出当前tile和poly和它的父结点
                    遍历当前结点可行走的邻接多边形,新结点?取邻接边中点赋值
                    计算消耗,当前邻接结点是目标多边形?F = 1当前结点cost(已花费) + 2当前结点pos到中点消耗 + 3中点到目标点消耗 + 0 : 1 + 2 + H
                    当前邻接结点在OPEN表内并且总消耗小于当前消耗?修改OPEN表内该结点消耗:加入OPEN表(会排序),当前最优点消耗小于已知最优点?更新最优点
            最优点不等于目标点?只找出了部分路径
            从最优点开始,找出父结点连接的路径,存储到PATH数组内
        Dijkstra算法
            1.建立二维数组V2,存储当前源点到其他点直接距离,不相邻为无穷大
            2.建立数组V1,存储源点到其他点的最短距离,长度为顶点数(多边形数),每个数组对象存储当前最短距离的父结点ID
            3.遍历每个顶点,检查经过该顶点到其他顶点的距离是否会缩短,修改其他顶点的最短距离和父结点,最终可以求出当前结点到所有点的最短距离和路径
            4.算法复杂度O(N^2)
        拐点法寻找最优路点路径
            1.首先找到起始多边形和穿出边的两个端点,连线L、R
            2.找出下一个穿出边左点,连线L',判断L'是否在L、R之间,如果在,则L更新为L',同理找出右点,连线R',判断R'是否在L、R之间,如果在,则R更新为R'
            如果L'R'都在L左侧或者R右侧,则L或R为一个拐点
            3.继续找出下一个拐点,直到目标多边形
        射线法判断目标点是否直接可达
            1.遍历初始多边形每条边,判断与射线AB是否相交(判断AOP BOP是否同向,同向不相交)
            2.通过穿出边找出下一个多边形,继续上述判断,直到碰到不可穿出区域或者到达目标区域