语言的基本构成
类型&变量
		 int uint 32位
		 short ushort 16位
		 float double 单精度32位 有效6位  双精度64位 lua采用双精度浮点数
					  IEEE754编码方式 符号位(1) + 指数位(8) + 尾数(23)
		 string char uchar 
					 字符数组和字符 
					 char*最后是一个\0字符  
					 C# char代表一个字符或者一个中文符号,长度不固定 
					 lua和C++一样 字符编码分为ASCII和Unicode  UTF-8和GBK是一种UNICODE实现方式
									UTF-8不定字节编码以字节数开头,0xxxxxxx 表示一个字节  110xxxxx表示2个字节,后续字节以10开头  最多会有6个字节
		 指针	它也是个变量,它的值是对象的地址,使用&运算符获取对象  p->等价于(&p).
				指针和引用变量赋值时必须匹配类型
		 引用	变量换了个名字,没有内存分配,它和它引用的变量用的是一份内存
				引用必须在声明时初始化
		 const  C++字面字符串 文件内的常量不可以const_cast 函数内的可以
				C#变量必须属于类,函数内变量不能加const和static
				顶层const：指针本身是个常量
				底层const：指针所指的对象是个常量
		 static	静态全局常量(文件内有效)
		 extern 外部变量
		 #define 宏定义 ##宏拼接 #宏替换
		 typedef 类型组合定义		 
类型转换 basic-type 隐式转换	
		 static_cast 基本类型之间相互转换,可替代隐式转换
					 类层次转换,父类到子类没有类型检查
					 void转换
		 const_cast只能改变底层const,也就是指针所指向的对象的const
		 dynamic_cast 用于指针和引用的类层次转换
		 reinterpret_cast 用于将二进制位解释为另一种类型
宏：	#代表后面的是个字符串
	    ##用于拼接变量
函数   引用&值参数传递 ...传递参数时只能传递基本类型
	   数组作为参数无法拷贝,所以传递过来之后会退化为指针
	   注意不要返回栈变量的指针,因为已经销毁了
	   函数指针  指针指向一个函数,可以直接P()调用
	   定义一个函数,返回函数指针 int (*f())()
类&继承 private public protected friend class 
		virtual vptr 重载 覆盖 vtable virtual=0 
		每个带有虚函数的类都有一个静态的虚表,每个带有虚函数的类对象都有一个虚表指针,在构造函数内初始化
		编译时多态性,模板,重载   运行时多态性,虚函数重写  
		虚继承,保证基类只有一份实例virtual-base-class  如果有构造函数,那么必须在最底层派生类里实现虚基类的构造,否则会有编译错误 
		构造初始化 拷贝赋值时指针 隐式转换
		友元函数不受访问权限影响
模板&泛型 template where限定 模板特例 template<> ret function<int>(){}
		  lambda [捕捉列表](参数列表){函数体}
		  bind 参数重新排列  bind(func,placeorders::_1,_2,var);
		  function<void(int,int)>
库&dll&依赖 __declspec(dllexport) __stdcall __cdecl
			IO库 iostream 控制台读写 cin>> cout<<
				 fstream 文件读写 成员函数 f("",ios::in|ios::out|ios:binary) 
										   f.close() 
										   eof()文件结尾
										   tellg() tellp() 用于获取当前文件读取或者写入的位置
										   seekg(offset,ios::cur) seekp() 用于移动读写指针到指定位置 ios::beg ios::cur ios::end
										   read(buffer,size) write(buffer,size) 字节数组读写
						C文件读写 open和write属于系统调用,低级IO无内存缓冲,不同操作系统不一样
								  fopen "path","wrab+"
								  fclose fp
								  fread buffer,size,count,fp
								  fseek fp off,seek_cur
								  ftell fp
				 字符串读写 strstream char*读写 istr(char*) 废弃的API,推荐使用string读写,因为char的不保证最后一个字符是'\0'
							sstream string读写 istr(string) clear() str()
				 IO流不能拷贝和赋值
			顺序容器 vector 插入元素push_back insert 删除元素erase clear 
					 list   插入元素push_back push_front insert 访问 front back 删除erase pop_front pop_back
					 stack  push pop top empty size
			迭代器 ::iterator iter = ww.begin() ww.end() cbegin cend rbegin rend
			算法库  algorithm numeric
					查找 find  find_if
					删除 remove remove_if
					赋值 fill fill_n
					替换 replace replace_if
					排序 sort
					去重 unique
			关联容器 map multimap  pair<>类型make_pair   添加元素insert 删除元素erase 
			右值引用,&&引用一个即将被销毁的对象,可用于move构造和赋值
常用基础函数 assert assert(ptr)
			 ctype  isupper islower isdigit isalpha toupper tolower
			 limit  最值宏定义
			 math   常用数学函数
			 signal 进程信号处理,signal函数用于注册信号处理函数,常见信号有
					SIGILL 非法指令  SIGINT 输入CTRL+D SIGABRT 终止 SIGCHLD 子进程异常停止 SIGFPE 除0异常 SIGKILL 杀死进程 SIGSEGV 非法内存访问 SIGSYS 非法系统调用
			 stddef NULL定义
			 stdlib 内存分配 malloc free 数值与字符串转换 atoi itoa 随机数 srand(seed) rand 系统操作 system exit abort 环境变量 getenv putenv
			 stdarg 不定长参数处理  __VA_ARGS__ va_list ap; va_start(ap,format); char buffer[512]; len = vsprintf(buffer,format,ap); va_end(ap);
			 string strcat(dst,src) strcpy(dst,src) strlen(src) strcmp(src,dst) c_str
			 ctime time(NULL) clock()当前运行经过的毫秒数
			 基础宏定义 __LINE__ __FUNCTION__ __FILE__

EFFECTIVE C++ 
			1.尽量使用const而不是#define, 宏定义没有类型检查
			2.构造、析构、赋值
			  编译期会默认生成 无参构造函数(没有构造函数时),拷贝构造函数、拷贝赋值运算符,不想要就声明为private,但不实现
			  如果基类或者派生类会有虚函数,那么基类析构函数必须是虚函数,有虚函数就会有虚表和虚表指针,虚表为静态,类共享,虚表指针为对象私有,初始化之后不会改变
			  析构函数要确保不能出现错误,否则会导致内存泄漏
			  构造和析构过程中不能调用虚函数,因为这个时候基类或者子类部分已被销毁或者尚未初始化
			  赋值运算符返回对象引用,注意自我赋值判断,注意复制指针内存
			3.资源管理
			  以对象的形式进行资源管理,依靠构造和析构函数来处理资源的初始化和释放
			  智能指针不能用于数组,因为析构调用的是delete而不是delete[]
			4.类的设计
			  API接口要简单清晰易用,不能有二义性
			  参数传递使用引用传递,临时对象会等引用结束后析构
			  返回值不能返回引用,主要针对临时对象,尽量只返回基本类型
			  成员变量私有,通过API修改其值
			  类功能尽量单一,尽量使用非成员函数完成额外的功能
			5.类的实现
			  变量在使用之前在定义
			  减少类型转换
			  降低文件依赖关系
			6.类的继承关系,体系结构
			  设计模式,接口继承与实现继承
			7.自增自减区别、
			8.抛出异常使用函数内静态变量,利用引用捕捉,防止对象拷贝同时防止异常对象是临时对象
			9.参数传递不能传递子类对象给基类对象,因为子类部分会被切掉,所以参数用引用比较合适
C++对象内存布局
			单继承  基类虚表+子类虚表,只有一个虚表,基类在前,子类在后,子类重写的在基类的对应位置
			多继承  会有N-1个虚表,第一个基类与子类合一,子类虚函数在第一个虚表内,
			菱形继承 这个时候要利用虚继承,这样每个子类有一个指向虚基类的指针,只有一份基类对象,该对象是由派生类初始化的(创建的哪个子类,哪个子类虚继承了父类)
			malloc是分配一块新的内存  realloc是在原内存后加长,可能会变化地址
编译执行  C++  GCC(LINUX) CL(WINDOWS) MINGW(WINDOWS)  

逆波兰式  后缀表达式,方便堆栈操作实现任意复杂度的表达式,一次扫描即可得出结果,遇到操作数压栈,遇到运算符弹出操作数并运算
		 波兰式即前缀表达式,对应于二叉树的前序遍历结果,逆波兰式对应于后序遍历结果

C++跳转
		goto:函数内跳转
		setjmp longjmp 非局部跳转
		setjmp(jmp_buf env) 设置跳转点,保存函数上下文 直接调用返回0,跳转调用返回longjmp第二个参数
		longjmp(jmp_buf env,int ret) 调到跳转点,恢复函数上下文
C赋值	int ? = (1,2,3,4,5); 会取最后一个值

C#   托管代码会被编译为IL语言(生成的文件内包含元数据),CLR编译IL为机器语言(JIT编译)
	  反射
			特性,继承自System.Attribute的类,放在类上面通过构造函数初始化,可以使用GetType().GetCustomAttributes(类型,继承)获取所有特性
			Reflection 反射程序集包含 Type 类型管理 Assembly 程序集管理
	  DLL
			Runtime程序集包含 InteropServices DllImport(dllName,EntryPoint,CharSet,CallVersion);  
			Marshal类 托管与非托管之间传递数据 GetFunctionPointerForDelegate Copy(byte[],start,intptr,length) Copy(intptr,byte[],start,length);
			unsigned char--byte  char*--string int int uint uint float float unsigned char* byte[]
	  语言	弱引用可以用来存储对象,当其他地方没有对象值得引用时,会被GC掉,弱引用不算引用
	        lua table里key和value都可以是弱引用
			结构体是值类型,参数传递是值传递  ref out会进行装箱拆箱操作,会创建class,数组是引用类型
			接口继承 : XX  interface XX  实现继承,继承class

python 
	   函数定义
			def name(params):
	   判断是否是主动执行
			__name__ == "__main__": 
	   设置文件编码
		   #coding:utf-8 
		   import sys
		   reload(sys)
		   sys.setdefaultencoding("utf-8")
	   当前脚本执行路径
		   import os
		   os.path.abspath(sys.path[0])
	   参数
		   sys.argv数组
	   数组  append   
	   循环  for var in 数组或者range(1,n):
	   文件操作  file = open(path,"wb")  file.write() file.close()
	   目录操作 是否为目录 os.path.isdir() 
				目录列表 os.listdir()
				删除空目录 os.rmdir()
				路径是否存在 os.path.exists()
				分解为文件名和路径 os.path.split()
				删除目录 shutil.rmtree()
				         shutil copy()文件夹
						 shutil copyfile 文件
						 shutil move 移动
						 shutil remove 删除文件
	   堆栈   traceback.print_exc()
	   输入  rawinput()
	   字符串  string[0:-3]  
	           string.split() 
			  字符串拼接 string.join(array)  "%s" % varname  a + b
			  替换replace
	   编码   python字符串是对象,有两种,
	   		  一个是str类型,可能是gbk或utf-8编码或者ascii编码 通过decode("gbk|ascii|utf-8")操作转换为unicode对象
	   		  一个是unicode类型,通过encode("gbk|utf-8|ascii")转换为str对象
	   		  判断对象类型 type(x) is unicode or type(x) is str
	   
	   库  excel库xlrd
	              excel = xlrd.open_workbook(path)
				  sheetnames = excel.sheet_names()
				  sheet = excel.sheet_byname(name)
				  cols = sheet.row_values(n)
				  ctype = sheet.cell(row,col)
				  value = sheet.cell_value(row,col);
lua API
模块实现相关 module local self 
             tostring tonumber type 
             get/setmetatable 
             get/setfenv 
             rawget/set
             unpack select
             pairs ipairs 
             print error assert
             class 
模块加载相关 require 
             dofile dostring 
             loadfile loadstring 
             pcall xpcall

库     math   库  abs ceil floor random randomseed cos sin acos asin tan atan exp log sqrt
       os     库  
       debug  库  traceback
       io     库  
       coroutine  
       package库  path cpath loaded preload loaders loadlib seeall
       string 库  lower upper len format reverse sub gsub find gmatch byte char dump match rep
       table  库  insert concat maxn remove sort
注册表: 所有lua_State共享的表
全局环境: _G全局表
栈帧:  分为函数栈帧和数据栈帧,每个函数的数据栈index属于不同的数据栈
       
Lua CAPI
后缀表达式:  建立符号栈,
             遍历中缀表达式
			   1.数字,直接输出
			   2.运算符 (入栈  )弹出符号栈元素,遇到)停止,)弹出但不输出  其他符号,弹栈直到遇到(或者遇到优先级低的符号停止
			   3.遍历完成,输出符号栈所有符号
常量定义 luaconf.h       
基础函数定义lua.h        以lua_为前缀
辅助函数定义luaxlib.h    以luaL_为前缀
库实现       以lua_open为前缀,具体实现分散在不同的.cc文件内  
			 lauxlib.c  辅助库实现
			 lbaselib.c base库实现
			 liolib.c  io库实现
			 lmath.c   math库实现
			 lstrlib.c string库实现
			 ltablib.c table库实现
			 loslib.c  os库实现
			 ldblib.c  debug库实现
			 linit.c  库注册入口函数整合
 
编译过程: 首先通过
		  将输入的代码块转换成可执行的closure,closure是运行期对象,编译期是proto,它由指令列表、常量表、子proto表、局部变量、UpValue构成
          一个函数编译后的汇编代码首先是 push ebp(此处esp指针会递减) move ebp esp,保存当前主调函数栈初始指针,被调函数栈初始指针,即保存程序现场,调用结束后esp已恢复至初始值,再次调用pop ebp恢复ebp为主调函数栈初始指针
核心实现  词法分析llex
          语法分析lparser
		  代码生成lcode
		  内存管理lmem lgc
		  元表ltm 表ltable 字符串lstring 函数lfunc
		  编译过的代码加载lundump
		  类型定义lobject  包括变量类型判断、类型转换、相等判断、获取&设置Tvalue不同的变量值
		  虚拟机lvm   基于栈的虚拟机(java python),操作数是放在虚拟机的栈上,模拟CPU操作  指令数较多,内存复制操作比较多  需要复制函数栈帧变量到虚拟机的栈上
		              注册表的虚拟机,操作数存放在虚拟寄存器内,使用一条指令即可完成,但是需要在代码生成阶段进行寄存器分配,指令直接包含操作数地址(函数栈帧的变量都已经对应好了虚拟寄存器),不需要复制数据到VM的栈上
					  luaV_execute() switch语句执行
		  操作码lopcodes Lua指令大小为32位6位操作码,剩余位数为操作数的寄存器

		   -1代表栈顶 1代表栈底
常用API:   C库函数实现&C#函数包装:  压栈: lua_pushnil lua_pushboolean lua_pushcfunction lua_pushcclosure lua_pushfstring(L,fmt,...) lua_pushinteger lua_pushnumber lua_pushlstring(L,s,l) lua_pushvalue(L,n)复制指定栈位置数据到栈顶
                                    出栈: lua_pop lua_toboolean lua_tocfunction lua_tointeger lua_tolstring lua_tonumber lua_tostring
									类型判断: lua_isnil lua_isnumber lua_istable lua_isstring
									函数注册luaL_Reg注册函数结构体 luaL_Reg[] = { {"func_name",func},{"func_name1",func1} }
									函数调用lua_call(L,narg,nresult) lua_pcall(L,nargs,nresults,err_func)
									table字段获取lua_getfield(L,stackid,k) lua_getmetatable lua_gettable lua_gettop 
									table字段创建lua_newtable 
									lua get和new push操作会在栈顶插入数据, pop set to会移除数据
									pushvalue复制指定位置数据到栈顶
       
lua库实现方式 1. 纯lua编写,作为模块文件存在,直接使用require加载即可使用
              2. C编写,lua.dll内部实现,C#去调用导出的注册函数,加入到全局table内
              3. C#编写,通过tolua框架生成WRAP文件,启动时调用注册函数添加到全局table内
			  





