PInvoke方式实现静态方法调用
			C++使用__cdecl __declspec(dllexport)导出API
			C#使用DllImport("dll") static extern调用API
			参数: 基本类型直接传递int float bool uint long
				  字符串string对应char* byte[]对应unsigned char*,传递时需要使用Marshal.Copy用于在托管与非托管之间转换内存 Marshal.Copy(src, start, dst, len);  Marshal.Copy(src, dst, start, len);
				  函数指针C#方法MonoPInvoke声明 MonoPInvokeCallback(typeof(C#CallBack))
			      结构体和类传递需要给C#结构体或者类添加StructLayout特性,用来标记这个对象的内存布局,使得传递给C++之后,C++可以直接转换为C++对象  StructLayout(LayoutKind.Sequential),RequiredByNativeCode
				  结构体或者类指针传递加上ref或者out标记
			
				  
				  
[MethodImpl(MethodImplOptions.InternalCall), WrapperlessIcall] 实现类方法调用			  
C++使用mono运行C# DLL,需要mono提供的库和头文件,注意c# dll需要使用 mono命令来生成, msc *.cs -t:library
	#include <mono/jit/jit.h>
	#include <mono/metadata/assembly.h>
	#include <mono/metadata/class.h>
	#include <mono/metadata/debug-helpers.h>
	#include <mono/metadata/mono-config.h>

	int main()
	{
		//初始化MONO运行环境,类似于创建lua虚拟机
		MonoDomain* domain = mono_jit_init("UNITY_MANAGED");
		//加载托管程序集,类似于LUA加载LUA脚本
		MonoAssembly* assembly = mono_domain_assembly_open(domain, "DLL_PATH");
		MonoImage* image = mono_assembly_get_image(assembly);

		//获取类和字段
		MonoClass* mono_class = mono_class_from_name(image,"DLL_NAME", "CLASS_NAME");
		MonoClassField mono_field = mono_class_get_field_from_name(mono_class, "FIELD_NAME")
		//获取要调用的方法
		MonoMethodDesc* entry_point_method_desc = mono_method_desc_new("DLL_NAME.CLASS_NAME:Main()", true);
		MonoMethod* entry_point_method = mono_method_desc_search_in_class(entry_point_method_desc, main_class);
		mono_method_desc_free(entry_point_method_desc);
		//调用方法
		mono_runtime_invoke(entry_point_method, NULL, NULL, NULL);
		//注册C++方法到C#中
		mono_add_internal_call("DLL_NAME.CLASS_NAME::METHOD_NAME", reinterpret_cast<void*>(C++_METHOD_PTR));
		
		//创建C#数组
		MonoArray* array = mono_array_new(domain, mono_class, COUNT);
		//创建C#类
		MonoObject* obj = mono_object_new(domain, mono_class);
		mono_runtime_object_init(obj);
        void* mono_field_value = &Components[i];  //Components是在C++中创建的,给C#对应字段赋值,这个字段是C++对象指针
        mono_field_set_value(obj, mono_field, &mono_field_value);
        mono_array_set(array, MonoObject*, i, obj);
		C#类对象转换为C++结构体指针,C#对象只保存了C++结构体的指针,就是上面创建对象时给字段赋的值
		Component* component;	
		mono_field_get_value(obj, mono_field, reinterpret_cast<void*>(&Component));
		
		//释放应用域
		mono_jit_cleanup(domain);

		return 0;
	}

Lua
	  1.数据结构
	  	lua_TValue结构
	  				p userdata
	  				b bool
	  				f c function
	  				i number long long
	  				n number double
	  	TString结构
	  				extra   
	  				shrlen  短字符串长度
	  				hash    字符串hash值
	  				lnglen  长字符串长度
	  				hnext   hash表
	  	stringtable结构
	  				hash hash表
	  	lightuserdata
	  	Proto		函数原型
	  	LClosure
	  	CClosure
		luaState结构
					CommonHeader  
						GCObject *next; lu_byte tt; lu_byte marked
						GC对象通用标记,GCObject是一个由GC对象构成的链表,tt代表该对象类型,marked代表GC标记
					l_G
						全局状态,通过newthread创建的所有luaState共享同一个
						newstate创建的都是独立的
					oldpc
						最后一次执行的指令信息
					status 
						标记当前线程运行状态,OK 语法错误 运行错误 GC错误 内存错误 协程中断
					nci ci baseci top stack stack_last openupvalue stacksize
						栈底、栈顶、栈空间、栈帧、函数栈、数据栈
					
					gclist		
						垃圾回收辅助
					twups
						其他luaState的数据栈
					errorJmp errfunc
						当前错误恢复跳转点 错误处理函数
					nny nCcalls
						可中断和不可中断的函数个数						
					hook basehookcount hookcount hookmask allowhook 
						调试钩子状态变量
		CallInfo结构
					base top 
						当前函数栈底、栈顶
					func extra
						当前函数、闭包变量
					savedpc
						执行到的指令
					previous next
						调用栈前后信息
					nresults callstatus
						预期返回值、调用状态
					k ctx 
						C函数yield回调
		global_State结构
					version 
							lua版本
					l_registry
							注册表
					strt 
							字符串池
					mt tmname
							基本类型的元表 元表默认方法名称 __add __sub等等
					mainthread
							主线程
					frealloc ud 
							内存分配器
					gc信息
	2.
	  压栈过程
	  	赋值 (TValue*)(L->top)->? = value;  递增++L->top;
	  出栈过程
	  	地址 正数 L->ci->func + idx           idx > 0
	  		 负数且大于注册表 L->top + idx    idx > LUA_REGISTRYINDEX
	  		 注册表 G(L)->l_registry		  idx == LUA_REGISTRYINDEX
	  		 UPVALUE 						  idx = LUA_REGISTRYINDEX - idx;  C函数没有UPVALUE
	3.保护模式
	  C语言的try catch,调用之前setjmp,如果出错调用longjmp返回







