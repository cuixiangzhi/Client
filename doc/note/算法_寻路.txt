路点寻路
    优点:快速实现,简单,可以走大路
    缺点:无法动态规避障碍、无法标记角色信息、无法标记地形信息、路径不平滑
导航寻路
    生成导航网格 
        概念
            高度场(HeightField) 根据cell(一般为0.2,0.2,0.2)大小在xyz三个方向切割,由体素构成的对象
            体素(Span) 三维空间的像素
            开放区间(CompactSpan) 垂直方向一列相邻实心体素的集合
            闭合区间(CompactCell) 垂直方向一列相邻空心体素的集合
            压缩的高度场(CompactHeightfield) 由开放区间和闭合区间构成
            层级的高度场(HeightfieldLayerSet)
            轮廓
            凸多边形
            细节多边形
        实现
            加载网格信息,每行不是v就是f,v代表一个顶点,f代表三角形,针对每个三角形创建AABB包围盒,然后创建二叉搜索树
            初始化配置信息 
                rcConfig
                    地形配置
                    bmin&bmax           根据输入的网格MESH信息计算出的AABB边界
                    w&h                 根据边界和单位大小计算出的xz平面的单位宽度和高度(也就是xz平面有多少个体素)
                    cs&ch               用户输入的xz平面单位大小,y方向单位大小, 一般为0.2米 0.3米,越小越精确,体素越多,生成速度越慢
                    角色配置
                    walkSlope           用户输入的行走单位的行走角度
                    agentRadius          根据用户输入的行走单位的最小半径计算出的单位半径    
                    agentHeight          根据用户输入的行走单位的最小高度计算出的单位高度
                    agentClimbHeight     根据用户输入的行走单位的脚步高度计算出的单位高度
                    多边形配置
                    maxVertPerPoly      凸多边形最大顶点数
                    输入网格信息
                    ntris&tris          三角形个数&三角形数组(三个点构成一个三角形,存储了顶点起始下标)
                    nverts&verts        顶点个数&顶点数组(三个表示一个顶点)
            创建高度场并初始化
                rcHeightField
                    bmin&bmax           从配置里读取的AABB边界
                    w&h                 从配置里读取的xz平面宽高
                    cs&ch               从配置里读取的每个单位x、y、z方向的单位大小
                    spans               从配置里读取宽高然后分配好的XZ平面的体素二维数组,大小为sizeof(rcSpan*) * w * h
            标记输入三角形区域ID
                    m_triareas          输入的三角面的区域类型,初始化为RC_NULL_AREA(不可行走)
                    nomal               每个三角面的法线,单位化之后Y值正好等于三角面倾斜角的cos值
                    倾斜角小于最大行走倾斜角度时标记为可行走区域 RC_WALKABLE_AREA(可行走)
            光栅体素化所有三角面
                    遍历每个三角面,计算其AABB包围盒tmin,tmax(也就是三个顶点的最小xyz,最大xyz)
                    根据包围盒计算zmin=[(bmax[2]-tmin[2])*(1/cs)],zmax=[(bmax[2]-tmax[2])*(1/cs)]
                    for z=zmin;z<=zmax;z+=dz(cs)
                    切割多边形,每次输入是三个点(一个三角面),输出仍然是三个点(水平方向切割Z轴)
                    逆时针遍历所有顶点,计算其Z值是否在切割线两侧,是则计算交点(按照等比三角形)加入输入多边形顶点数组内
                    for x=xmin;x<=xmax;x+=dx(cs)
                    切割多边形,计算切割后多边形Y方向ymin,ymax,填充x,z处的y方向体素信息(ymin到ymax之间都是实心填充,只包含一部分也算实心)
                    添加体素时计算yminymax相邻区域是否有体素,有就合并,没有则插入新的体素,每个体素包括ymin,ymax,area,next
            过滤
                根据climbHeight计算Y方向相邻体素距离,如果上一个体素可行走并且当前体素不可行走,当前体素距离小于climbHeight,则标记当前区域可行走
                根据climbHeight计算XZ方向相邻体素距离,如果当前体素周围四个体素到达该体素距离均大于climbHeight,则标记为不可行走
                根据climbHeight计算每个体素最大值和最小值之差,如果小于agentHeight,说明该体素不可行走
            TODO 以下配置尚不明确具体用途
            轮廓配置
            maxEdgeLen          根据用户输入的轮廓的最大边长计算出的最大边长单位
            maxSimpleError      用户输入的简化后的轮廓需要分割的最大长度
            maxRegionArea       区域的最小面积
            mergeRegionArea     区域的合并最小面积
            detailSampleDist    采样距离
            detailSampleMaxError采样最大值
            tileSize
            borderSize
            光栅化 计算三角形AABB
                   在xz平面切割三角形(切割过程新增切割点),y方向是连续的,切割后是一个实心体素集(Span)
                   检查当前列是否有Span,如果有就合并,合并时根据Climp大小标记区域可行走性质
            过滤可行走体素 根据角色脚步来过滤y方向(此时不能保证相邻的体素限制角色高度)
            过滤可行走体素 根据角色脚步和角色高度来过滤xz方向
            过滤可行走体素 根据角色半径来过滤无法站立的地方
            创建压缩的高度场 压缩到XZ平面,CompactCell为压缩后的数据,CompactSpan为压缩后的Span
            过滤可行走体素 根据体素距离边界的最小距离和角色半径*2比较,水平相邻距离为2,斜对角为3,离边界越远距离越大
                           默认格子大小为0.3(1倍距离),角色半径为0.6(2倍距离),默认判断2*2距离才可以站立
            区域分割       根据最大最小面积合并相邻的Span(标记为相同的region),并对相邻区域建立连接
            区域描边       根据分割好的区域找出边缘体素集合,然后根据最大边长和误差简化边缘
                           合并一些相邻的轮廓边
            生成多边形     根据描边集合和多边形顶点数限制生成凸多边形
            生成细节多边形 根据体素高度信息生成凸多边形的三角形集合
            标记区域特点   根据多边形区域ID标记区域是
    寻路相关算法
        寻找最近的多边形
            遍历所有的多边形,判断点是否在多边形内部(pnpoly算法)并计算与每条边的距离
            点在多边形内部则计算其高度,利用向量加法AP = u * AB + v * BC)
            不在多边形内部则返回目标点
        启发式搜索算法A*
            1.建立OPEN表(有序队列),和CLOSE表,OPEN表插入初始结点
            2.循环.
                弹出OPEN表头结点,插入CLOSED表
                当前结点是目标结点?结束循环
                遍历当前结点子结点
                    计算到目标点消耗
                    已在OPEN表或者CLOSED表并且消耗大于结点消耗?检查下一个结点
                    新的结点或者是消耗变的更小了,从CLOSED表移除,插入OPEN表,排序,修改其父结点
            3.已找到目标结点?反向遍历父结点,找出正序结点路径
        Dijkstra算法
            1.建立二维数组V2,存储当前源点到其他点直接距离,不相邻为无穷大
            2.建立数组V1,存储源点到其他点的最短距离,长度为顶点数(多边形数),每个数组对象存储当前最短距离的父结点ID
            3.遍历每个顶点,检查经过该顶点到其他顶点的距离是否会缩短,修改其他顶点的最短距离和父结点,最终可以求出当前结点到所有点的最短距离和路径
            4.算法复杂度O(N^2)
        拐点法寻找最优路点路径
            1.首先找到起始多边形和穿出边的两个端点,连线L、R
            2.找出下一个穿出边左点,连线L',判断L'是否在L、R之间,如果在,则L更新为L',同理找出右点,连线R',判断R'是否在L、R之间,如果在,则R更新为R'
            如果L'R'都在L左侧或者R右侧,则L或R为一个拐点
            3.继续找出下一个拐点,直到目标多边形
        射线法判断目标点是否直接可达
            1.遍历初始多边形每条边,判断与射线AB是否相交(判断AOP BOP是否同向,同向不相交)
            2.通过穿出边找出下一个多边形,继续上述判断,直到碰到不可穿出区域或者到达目标区域