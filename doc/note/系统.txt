系统组成
	   单内核系统核心模块在一起,模块之间交互使用函数调用
	   微内核系统模块独立,模块之间交互使用进程通信
	   模块实现 模块编译 模块管理
	   系统启动
			  通电->CPU执行BIOS固定地址跳转指令->
			  BIOS程序启动->POST加电自检->
			  必要硬件BIOS初始化->次要硬件初始化->磁盘读取MBR
			  加载kernel,启动init进程,启动登录tty,
			  tty调用open打开终端等待用户输入用户名,
			  启动login进程等待输入密码,
			  登录成功,切换到当前用户主目录chdir,修改终端拥有者chown,修改终端权限chmod,设置进程组ID
文件管理
		硬盘
			硬盘由N各盘片组成,盘片两个面都可以读写
			磁头: 盘片的读写装置,每个面一个
			磁道: 同一盘片不同半径的同心圆
			柱面: 不同盘片相同半径的同心圆
			扇区: 同一盘片的扇形区域
			容量: 磁头数量*磁道数量*扇区数量*扇区字节数
			分区: 操作系统进行管理的逻辑上的分区,必须格式化为指定的文件系统才可以使用
		文件系统
			文件系统定义了磁盘分区的存储、读写方式,FAT32 NTFS NFS EXT等等
			虚拟文件系统,对文件系统的抽象,封装了不同文件系统之间的差异性
			设备文件也属于一种文件系统
		存储结构
			基本信息存储在INODE内,INODE包含了文件的大小、读写日期、拥有者、偏移地址
			目录文件由一系列文件名->INODE号组成
			硬链接: 文件名不同,INODE相同
			软连接: 文件名不同,其中一个指向另一个文件,相当于快捷方式 ls -s
		文件编码
			大端模式: 把字节按顺序存储,即低地址存储高字节,高地址存储低字节
			小端模式: 正好相反
			字符集和字符编码,字符集是一个数字,编码是这个数字的存储方式
			UNICODE字符集,有UTF-8 UTF-16 UTF-32等
			ASCII既是字符集也是字符编码
			GB2312是字符集
			zh_cn.utf-8 是本地系统语言及字符集,国家_语言.字符编码
			C# string是unicode对象,静态字符串初始化会根据cs文件编码解码
			python 分为str和unicode两种对象,decode解码为unicode对象,encode编码为str对象
			terminal 会根据设置的编码来显示传输的字节
			MSVC
				bom 字节序标记,表明了文件编码,不带BOM的话会按照系统编码来解释
				源码编码: 源代码文件的编码,分为带BOM和不带BOM
				执行编码: 二进制文件内字符编码,编译时会根据系统编码来设定
				解释编码: 终端编码
			GCC
				源码编码: -finput-charset=utf-8 不设置则默认UTF-8
				执行编码: -fexec-charset=utf-8 -fwexec-charset= 不设置则默认UTF-8
		文件格式
			PE格式 windows下二进制文件格式
			ELF格式 unix下二进制文件格式
				.text代码段 .data数据段 .rodata只读数据段 .bss全局、静态数据段 
				.init _init函数 .init_array constructor特性标记的函数
				.fini _fini函数 .fini_array destructor特性标记的函数
				.got 外部模块变量、函数地址
				有码加密 
					__attribute__(section(.text))
					__attribute__(constructor())
					__attribute__(destructor())			
			 	无码加密 
			 		根据ELF格式查找函数代码段,对.dynamic内的重要函数进行加密
				  	函数查找过程: name->hash->nbuckets->bucket->.dynamic->Elf32_Sym->st_name->.dynstr->chain
				  	解密过程也是需要找到so地址,获取权限,解密内存 
			MACH-O格式

内存管理
		内存布局: 
				stack-map-heap-bss-rwdata-rodata-code
		内存分配: 
			  	brk系统调用分配小于128KB内存,中间内存碎片无法释放,mmap系统调用分配大于128KB内存,自由释放
			  	具体大小可由M_MMAP_THRESHOLD来调节 M_TRIM_THRESHOLD调节堆碎片紧缩值

			  	new/delete new[]/delete[] 分配/释放内存,然后调用构造/析构函数
			  	malloc/free 只负责分配/释放内存
			  	mmap(NULL,size,PROT_READ|PROT_WRITE|PROT_EXEC,MMAP_PRIVATE,fd,offset);
			  	munmap(PTR,size);
			  		头文件 sys/mman
			  		mmap有SHARED和PRIVATE两种方式,即共享内存和私有内存,前者会写入文件,后者不会
			  		mmap共享模式下映射大小不大于文件大小,多余部分不会写入文件(页对齐)
			  		fseek可以设置文件大小
			  		msync同步共享内存写入到映射文件
			  	shmget(key,size,IPC_CREAT)
			  		头文件 sys/shm sys/ipc
			  		SHM需要先创建共享内存,然后映射到进程地址空间内,shmat(&sid,NULL,0);
			  		取消映射使用shmdt(PTR);
			  		删除内存使用shmctl(sid,IPC_RMID,NULL);
			  		shm映射内存不会写入文件,进程退出不删除则系统关机才会删除
			  	FileMap
			  		windows共享内存机制
			  		创建共享内存 CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,SIZE,KEY);
			  		打开共享内存 OpenFileMapping(FILE_MAP_ALL_ACCESS,TRUE,KEY);
			  		进程映射内存 MapViewOfFile(handle,FILE_MAP_ALL_ACCESS,0,0,0);
			  		取消内存映射 UnmapViewOfFile(PTR);
			  		关闭共享内存 CloseHandle(handle)
		  		VirtualAlloc
		  			ntdll的API,windows虚拟内存
			  	DLL映射
			  		映射到内存,内存修改不会写入文件
		内存权限
				mprotect(ADDR,LEN,PROT_READ | PROT_WRITE | PROT_EXEC);
进程管理
		进程关系
			父子进程: fork创建进程,pid为0是子进程,大于0是父进程
			僵尸进程: 子进程的退出状态,等待父进程调用waitpid(-1,NULL,0)回收;
			孤儿进程: 子进程的状态,父进程退出但是子进程没有退出,子进程会由init进程收养
		进程创建
			fork创建进程,调用execl(path,name,args)覆盖进程空间执行新程序代码;
		守护进程
			孤儿进程循环或者周期检测目标程序,崩溃后重启,监视运行状态
			该进程后台运行,没有终端与之关联
			fork();setsid();fork();close(0);close(1);close(2);open("/dev/null",O_RDWR);dup(0);dup(0);
		进程外挂
			ptrace提供控制另一个进程的能力,检测、修改代码、数据、寄存器、断点、注入、跟踪
			调试 PTRACE_ATTACH PTRACE_DETACH PTRACE_CONT PTRACE_SINGLESTEP PTRACE_SYSCALL
			读取 PTRACE_PEEKTEXT PTRACE_PEEKDATA PTRACE_PEEKUSR
			写入 PTRACE_POKETEXT PTRACE_POKEDATA PTRACE_POKEUSR
线程管理
		线程创建
			pthread_create(&pid,NULL,loopfunc,NULL);
			pthread_self()获取线程ID
			pthread_exit(NULL);退出当前线程
		线程同步
			pthread_mutex_init(&mid)
			pthread_mutex_lock(&mid);
			pthread_mutex_unlock(&mid);
			pthread_rwlock_init(&rwid);
			pthread_rwlock_rdlock(&rwid);
			pthread_rwlock_rdunlock(&rwid);
进程通信
		本地通信
				mmap shm filemap
		网络通信
				sys/socket arpa/inet netinet/in
				winsock2 comment(lib,"ws2_2.lib")
				INVALID_SOCKET SOCKET_ERROR INADDR_ANY
				创建连接
						int sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
						地址
							sockaddr_in addr;
							addr.sin_family = AF_INET;
							addr.sin_addr.s_addr = inet_addr(host); ntoa(); htonl();
							addr.sin_port = htons(port); ntohs();
							客户端不需要绑定
							bind(sock,(sockaddr*)&addr,sizeof(sockaddr));
						连接						
							connect(sock,(sockaddr*)&addr,sizeof(sockaddr));
						监听
							listen(sock,5);
				接受连接
						accept阻塞模式下没有连接到来时会进入挂起状态
						clientsock->id = accept(sock,(sockaddr*)&clientsock->addr,&size);
						clientsock->port = ntohs(clientsock->addr.sin_port);
						strncpy(clientsock->host,inet_ntoa(clientsock->addr.sin_addr),SIZE);
				收发数据
						send阻塞模式下发送缓冲区不足时会一直阻塞
						send非阻塞模式下会返回拷贝内存大小
						recv阻塞模式下返回0连接关闭 -1接收出错 错误号EWOULDBLOCK EAGAIN EINTER
						send(sock,buff,size,0);
						recv(sock,buff,size,0);
						sendto(sock,buff,size,0,(sockaddr*)&addr,sizeof(addr));
						recvfrom(sock,buff,size,0,(sockaddr*)&addr,sizeof(addr));
				断开连接
						closesocket(sock);
				连接状态
						SOCKET收发缓冲区
					   	g/setsockopt(sock,SOL_SOCKET,SO_RCVBUF,&size,sizeof(UINT))   设置接收缓冲区大小
					   	g/setsockopt(sock,SOL_SOCKET,SO_SNDBUF,&size,sizeof(UINT))   设置发送缓冲区大小
					   	g/setsockopt(sock,SOL_SOCKET,SO_RCVTIMEO,&timeout,sizeof(INT)) 设置接收超时时间
					   	SOCKET阻塞非阻塞
					   	ioctlsocket(sock,FIONBIO,0)
					   	fcntl(sock,F_GETFL,O_NONBLOCK)
					   	SOCKET关闭行为
					   	linger l; l.l_onoff = 1; l.l_linger = 0;
					   	g/setsockopt(sock,SOL_SOCKET,SO_LINGER,&L,sizeof(linger)) 设置关闭时是否发送缓冲区数据和超时时间
					   	g/setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,1,sizeof(INT)) 启动服务器时保证端口可被多个IP重用
				多路复用
						select FD_SETSIZE是单线程最大连接数
							//创建轮询数组
							fd_set; FD_ZERO(&fds); FD_SET(fd,&fds); FD_CLR(fd,&fds);
							//阻塞等待数据
							select(max_fd_no + 1,&read_fds,&write_fds,&exception_fds,&timeout);
							//遍历检查FD_ISSET(fd,&fds); 
							空闲FD比较多的时候遍历消耗,尤其是有上千个FD的时候
						epoll ulimit -n是最大描述符个数
							创建epoll文件 
										int ed = epoll_create(size);
							添加事件监听 
										epoll_event event; 
										event.events = EPOLLIN | EPOLLET; 读和边缘触发
										event.data.fd = fd;
										epoll_ctl(ed,EPOLL_CTL_ADD,fd,event); 
										事件可以是EPOLL_CTL_ADD添加 EPOLL_CTL_MOD修改 EPOLL_CTL_DEL删除
										ET模式只有状态发生变化才有通知,数据未读完不会有通知
										LT模式只要有数据就一直有通知
							等待事件发生
										epoll_event events[size];
										epoll_wait(ed,events,max_events,timeout);
交叉编译
		GCC编译 
            -g -m64 -O2 -c -o -I -static -l -std -fPIC -shared -Wl 
            ar rcs
        GDB调试
        	gdb --pid
        	r 运行
        	c 继续
        	n F10
        	s F11
        	b 文件:行号 函数 
        	d 删除断点
        	p 打印
        	
		NDK编译 
			LOCAL_PATH := $(call my-dir)
			include $(CLEAR_VARS)
			LOCAL_MODULE := module_name
			LOCAL_CFLAGS :=
			LOCAL_CPPFLAGS := $(LOCAL_CFLAGS)
			LOCAL_LDLIBS := 
			LOCAL_C_INCLUDES := 
			LOCAL_SRC_FILES :=
		  	$(call import-add-path, $(LOCAL_PATH)/)
		  	LOCAL_WHOLE_STATIC_LIBRARIES +=
		  	include $(BUILD_STATIC_LIBRARY) 当前模块是一个静态库 .lib or .a
		  	include $(BUILD_SHARED_LIBRARY) 当前模块是一个动态库 .dll or .so
		  	include $(BUILD_EXECUTABLE)     当前模块是一个可执行程序
		  	$(call import-module,../../xxx)

			APP_STL := gnustl_static
			APP_ABI := armeabi-v7a x86
			APP_OPTIM := release
			APP_PLATFORM := android-16
		MAC编译
			一个scheme对应一个target
			导出archive  
				xcodebuild archive -scheme xx -configuration Debug|Release -archivePath *.xcarchive -quiet>null
			导出ipa 
				xcodebuild -exportArchive -archivePath *.xcarchive -configuration D|R -exportPath *.ipa -exportOptionsPlist