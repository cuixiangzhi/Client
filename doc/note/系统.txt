系统组成
	   单内核系统核心模块在一起,模块之间交互使用函数调用
	   微内核系统模块独立,模块之间交互使用进程通信
	   模块实现 模块编译 模块管理
	   系统启动
			  通电->CPU执行BIOS固定地址跳转指令->
			  BIOS程序启动->POST加电自检->
			  必要硬件BIOS初始化->次要硬件初始化->磁盘读取MBR
			  加载kernel,启动init进程,启动登录tty,
			  tty调用open打开终端等待用户输入用户名,
			  启动login进程等待输入密码,
			  登录成功,切换到当前用户主目录chdir,修改终端拥有者chown,修改终端权限chmod,设置进程组ID
内存管理
	mmap(0表示系统选择映射区起始地址,需要映射的字节数,PROT_READ | PROT_WRITE | PROT_EXEC,RESERVE | COMMIT,-1表示匿名新建文件,0);
	munmap(addr,len)释放文件
	shmget()
	shmat
	shmdt
	shmctl
	HANDLE handle = CreateFileMapping(0xFFFFFFFFFFFFFFFF,NULL,PAGE_READWRITE,sizeMax,sizeMin,mapKey)
	HANDLE handle = OpenFileMapping(FILE_MAP_ALL_ACCESS,TRUE,mapKey)
	void* ptr = MapViewOfFile(handle,FILE_MAP_ALL_ACCESS,0,0,0)
	UnmapViewOfFile(ptr)
	CloseHandle(handle)
  虚拟内存
	  每个进程都有自己独立的虚拟内存空间,32位系统是4G,64位系统是16EB,这个地址是逻辑地址
	  进程地址空间划分
	    1.内核空间,存放所有进程共享的dll及其数据 32位一般为2G,64位为248TB
		2.用户空间,真实可用的进程虚拟内存空间    32位一般为2G,64位为8TB
	  内存分配
			  预定 RESERVE 和 COMMIT两步,第一步预定虚拟地址空间,第二步分配并映射物理内存  PAGE_READWRITE 物理页面可读可写
	  交换内存
			  访问数据时,虚拟地址映射到内存,直接访问内存,
			  不在内存中,发生页面错误,内存换出换入页面文件,换入换出越频繁,内存访问就越慢
	  执行文件
			  进程启动时,会把程序可执行文件映射到进程虚拟内存中,这样就不需要物理内存了
文件管理
		硬盘
			硬盘由N各盘片组成,盘片两个面都可以读写
			磁头: 盘片的读写装置,每个面一个
			磁道: 同一盘片不同半径的同心圆
			柱面: 不同盘片相同半径的同心圆
			扇区: 同一盘片的扇形区域
			容量: 磁头数量*磁道数量*扇区数量*扇区字节数
			分区: 操作系统进行管理的逻辑上的分区,必须格式化为指定的文件系统才可以使用
		文件系统
			文件系统定义了磁盘分区的存储、读写方式,FAT32 NTFS NFS EXT等等
			虚拟文件系统,对文件系统的抽象,封装了不同文件系统之间的差异性
			设备文件也属于一种文件系统
		存储结构
			基本信息存储在INODE内,INODE包含了文件的大小、读写日期、拥有者、偏移地址
			目录文件由一系列文件名->INODE号组成
			硬链接: 文件名不同,INODE相同
			软连接: 文件名不同,其中一个指向另一个文件,相当于快捷方式 ls -s
		文件编码
			UNICODE是编码方式,UTF-8是存储方式
					C# string编码和cs文件编码有关系,对string进行初始化会按照cs文件编码进行解码
				文件内容和cs文件编码无关,文件内容读取时要和写入时使用的编码一致
				printf打印时只是输出了字节,字节的解释是靠终端来进行的,因此终端编码和输出编码要一致
			C++ MSVC编译期处理C++字符串时会把文件编码格式的字符串转码为本地操作系统的编码格式,所以C++代码内最好别用中文,除非是日志。
				GCC字符串编码和文件编码一样的
				读取文件时或者接收网络数据时都是按照二进制接收的,所以二进制是UTF-8编码,那么接收到的也是UTF-8
		文件格式
			PE格式
			ELF格式
			MACH-O格式
		文件加密 
			有码加密 __attribute__设置函数属性				
					section特性把指定函数放入输入段(link的输入)
					对指定的section加密,需要熟悉ELF文件格式
					constructor特性 标记该函数在main函数之前执行
					对指定的section加密,需要获取so地址(/proc/pid/maps),修改权限
			 无码加密 
			 		根据ELF格式查找函数代码段,对.dynamic内的重要函数进行加密
				  函数查找过程: name->hash->nbuckets->bucket->.dynamic->Elf32_Sym->st_name->.dynstr->chain
				  解密过程也是需要找到so地址,获取权限,解密内存 
进程管理
		进程关系
			父子进程: fork创建进程,pid为0是子进程,大于0是父进程
			僵尸进程: 子进程的退出状态,等待父进程调用waitpid(-1,NULL,0)回收;
			孤儿进程: 子进程的状态,父进程退出但是子进程没有退出,子进程会由init进程收养
		进程创建
			fork创建进程,调用execl(path,name,args)覆盖进程空间执行新程序代码;
		守护进程
			孤儿进程循环或者周期检测目标程序,崩溃后重启,监视运行状态
			该进程后台运行,没有终端与之关联
			fork();setsid();fork();close(0);close(1);close(2);open("/dev/null",O_RDWR);dup(0);dup(0);
线程管理
		线程创建
			pthread_create(&pid,NULL,loopfunc,NULL);
			pthread_self()获取线程ID
			pthread_exit(NULL);退出当前线程
		线程同步
			pthread_mutex_init(&mid)
			pthread_mutex_lock(&mid);
			pthread_mutex_unlock(&mid);
			pthread_rwlock_init(&rwid);
			pthread_rwlock_rdlock(&rwid);
			pthread_rwlock_rdunlock(&rwid);
进程通信
	  	本地进程
			pipe(&fds) fds[0]是读管道,fds[1]是写管道,匿名管道只能在父子进程间使用  unistd
			popen,打开一个进程并传递一些数据,他不会阻塞进程,返回FILE*文件流        stdio
			mkfifo("",)创建命名管道,不同进程以只读或者只写打开文件                 sys/types sys/stat
			共享内存,同一块物理内存,进程分别映射到自己的逻辑地址,共享内存不提供同步机制,需要自己额外控制,共享内存由进程控制 sys/shm
				  共享内存是一个对象需要的堆空间
				  int shmget(key,size,666) 创建共享内存
				  void* shmat(HANDLE,NULL,0)  把共享内存映射到进程逻辑地址,返回映射地址指针
				  int shmdt(addr)		   取消映射
				  shmctl(key,IPC_RMID,NULL)删除共享内存
				  
				  windows下使用文件映射
				    handle = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,SIZE,"key对应的字符串");
					handle = OpenFileMapping(FILE_MAP_ALL_ACCESS,TRUE,"KEY")
					char* PTR = MapViewOfFile(handle,FILE_MAP_ALL_ACCESS,0,0,0)
					UnMapViewOfFile(PTR);
					CloseHandle(handle);
			信号量,用于控制系统资源可用数量,互斥锁是非0即1的变量,只能控制线程资源 sys/sem.h
				  int semget(key,1,IPC_CREAT)创建或者返回已有的信号量	
网络通信
交叉编译
		GCC编译 
            -g -c -o -I -static -l -std -fPIC -shared -Wl 
            ar rcs
		NDK编译 
			LOCAL_PATH := $(call my-dir)
			include $(CLEAR_VARS)
			LOCAL_MODULE := module_name
			LOCAL_CFLAGS :=
			LOCAL_CPPFLAGS := $(LOCAL_CFLAGS)
			LOCAL_LDLIBS := 
			LOCAL_C_INCLUDES := 
			LOCAL_SRC_FILES :=
		  	$(call import-add-path, $(LOCAL_PATH)/)
		  	LOCAL_WHOLE_STATIC_LIBRARIES +=
		  	include $(BUILD_STATIC_LIBRARY) 当前模块是一个静态库 .lib or .a
		  	include $(BUILD_SHARED_LIBRARY) 当前模块是一个动态库 .dll or .so
		  	include $(BUILD_EXECUTABLE)     当前模块是一个可执行程序
		  	$(call import-module,../../xxx)

			APP_STL := gnustl_static
			APP_ABI := armeabi-v7a x86
			APP_OPTIM := release
			APP_PLATFORM := android-16
		MAC编译
			一个scheme对应一个target
			导出archive  
				xcodebuild archive -scheme xx -configuration Debug|Release -archivePath *.xcarchive -quiet>null
			导出ipa 
				xcodebuild -exportArchive -archivePath *.xcarchive -configuration D|R -exportPath *.ipa -exportOptionsPlist