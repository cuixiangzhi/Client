图形学
	图形 线框图 真实感图形 图像 图形方程 几何属性 非几何属性
	渲染流水线--->CPU提供VBO/VAO给GPU---对设定的顶点挨个执行顶点着色器,顶点着色器Uniform(顶点一致)和Attribute(顶点私有)由CPU提供,此阶段进行MVP变换
			  --->图元装配--->光栅化,根据输入图形计算出像素片段-->片段着色器-->像素归属测试(多窗口)-->裁剪测试-->Alpha测试-->深度测试-->模板测试-->颜色混合
硬件
	独立显卡通过数据线与显示器连接
	VGA接口输入是模拟信号,通过显卡的RAMDAC转换
	HDMI&DVI接口输入是数字信号,显卡直接传输
	刷新频率是指CRT每秒能画几帧
	显示器的硬件信息显卡可以读取到
	PC端显卡包括ADM RadeOn HD和NVIDA Geforce GTX
	移动端显卡包括POWERVRSGX(苹果)、MAIL(华为)、高通(小米)
	垂直同步 显卡的一个模块每个固定间隔产生一个信号(间隔根据显示器刷新频率范围设定,一般为60HZ)
	         这个信号每次都会发送给CRT显示器
	         打开垂直同步是指这个信号也发送给显卡的图形处理模块
驱动
	openGL是一个规范,各个显卡硬件厂商制作遵循该规范的驱动程序
	驱动跟硬件关联,OpenGL个DX都是调用了驱动的API
	OpenGL跨平台 glut跨平台输入
	OPENGL ES用于ANDROID 
	METAL用于IPHONE 
	DX只能用于WIN
坐标
	世界坐标系
		左手坐标系 x右y上z里
		右手坐标系 x右y上z内
	屏幕坐标系 
		unity中左下角为(0,0) 右上角为显示屏幕的(w,h)
		ngui中中心点为(0,0)
		gui左上角为(0,0)
		glut窗口左上角为(0,0)
	模型坐标系
		局部坐标系,是指模型本身的坐标系,以物体中心为原点,有自己的xyz轴
		默认放入世界坐标系的模型,局部坐标系和世界坐标系是重合的
	视图坐标系
		摄像机局部坐标系
	视口坐标系
		屏幕坐标系的子窗口,坐标为(x,y),大小为(w,h)
变换 变换计算从左往右,变换顺序从右往左看
	矩阵相乘  AmnBxy必须满足n==x,列向量表示法为左乘,行向量右乘
	三角变换  cos(a+b) = cosa*cosb - sina * sinb     cos(a-b) = cosa * cosb + sina * sinb
	平移变换  P' = T*P 
			  平移矩阵 |1 0 0 0|   逆矩阵 直接把txtytz变成负的即可
			  		   |0 1 0 0|
			  		   |0 0 1 0|
			  		   |tx ty tz 1|
	旋转变换  P' = R*P
			  旋转矩阵,二维旋转一般是绕基准点旋转,可以先平移至基准点,绕原点旋转,在平移回原位置
			  		       |cosA -sinA 0|
			  		   T * |sinA  cosA 0| * T^ = 
			  		   	   | 0      0  1|
			  		   三维旋转需要先将旋转轴平移旋转使其与坐标轴Z重合,然后绕Z轴旋转

			  		   旋转轴定义: 与Z轴夹角A,与X轴夹角B,可定义一个旋转轴 或者方向向量
			  		   			   旋转时先旋转使得Z轴与旋转轴重合
			  		   			   先绕Z轴旋转B角度,在绕Y轴旋转A角度,在绕Z轴旋转C角度,在绕Y轴逆转A角度,在绕Z转逆转B角度
			  欧拉角  xyz分别代表绕局部XYZ轴的旋转,这个旋转角度值和旋转顺序有关系、
			  		  unity中旋转顺序是zxy
			  		  连续差值不平滑
			  		  同一个旋转有不同的表达方式,万向节锁
			  		  转换为旋转矩阵需要太多的sin cos计算,没有四元数简单
			  		  R = RzRxRy
			  四元数  差值平滑,没有万向节锁
			  		  表示方式  rotation = (x,y,z,w) x = VxSin(0/2) y = VySin(0/2) z = VzSin(0/2) w = Cos(0/2)
			  		  四元数转换为旋转矩阵
			  		  		 1-2y^2-2z^2    2(xy-zw)    2(xz+yw)     0
			  		  		 2(xy+zw)      1−2x^2−2z^2  2(yz-xw)     0
			  		  		 2(xz−yw)       2(yz+xw)    1−2x^2−2y^2  0
			  		  		    0               0          0         1
			  		  旋转矩阵转换为四元数
			  		  		x = (m32-m23)/4w  y = (m13-m31)/4w z = (m21-m12)/4w w = (根号 1 + m11 + m22 + m33)/2
			  		  欧拉角转换为四元数
	缩放变换  P' = S*P
	堆栈      进入流水线的顶点都要乘上矩阵堆栈的当前堆栈,进行变换
			  GL_PROJECTION表示要设置投影矩阵,可以使用glOrtho(左右下上近远)或者glPerspective(角度,宽高比,近平面,远平面)
			  GL_MODEVIEW表示要设置模型视图矩阵,可以使用glLookAt() glTranslate等对已有的顶点进行变换
	M矩阵     T(局部偏移) * R(局部旋转) * S(局部缩放)
			  得出以父结点为世界坐标系的世界坐标,然后递归查找父结点,进行坐标变换,没有父结点那就是最终世界坐标
	V矩阵     经过M矩阵变换,物体与摄像机均处于世界坐标系下,现在要把物体转换到摄像机坐标系下
			  V = 摄像机矩阵的逆变换  即 T R S逆矩阵
    P矩阵     投影矩阵分为透视投影和正交投影
    		  透视投影 fov aspect near far
    		  		   投影变换把坐标变换到了裁剪坐标系(范围是-z到z,-z到-z,-z到z之间)
    		  		   		假设Xn = Xp * (2 / r - l) + B; Xp为r时Xn为1,最终解得Xn=[(2n/(r-l)*Xe + (r+l)/(r-l)*Ze]/Ze
    		  		   		同理Yn= [(2n/(t-b)*Ye + (t+b)/(t-b)*Ze]/Ze
    		  		   		Zn = (AZe + B)/Ze; Ze范围是n到f,因此Zn=[(f+n)/(f-n)*Ze - 2fn/(f-n)]/Ze
    		  		   		Wn为1
    		  		   		此时Xn是-1到1之间,Yn也是-1到1之间,Zn是-1到1之间,Wn是1
    		  		   		齐次坐标要保留Z信息,变为(Xn*Ze,Yn*Ze,Zn*Ze,Ze) 
    		  		   		为了方便计算可以令r-l或者t-b始终为1,减少除法计算,根据宽高比计算出高度或者宽度
    		  		   透视除法把坐标变换到了设备坐标系(范围是-1到1,-1到-1,-1到1之间)
    		  		   		投影变换得到的裁剪齐次坐标除以Ze得出NDC坐标
    		  		   视口变换把坐标变换到了屏幕坐标系
    		  		   		这个时候需要根据-1到1映射到屏幕的0到w 0到h上
    		  		   最终需要计算出NDC坐标,(Xn,Yn,Zn) = (Xp/Zcamera,Yp/Zcamera,Zp/Zcamera)
    		  正交投影 left right bottom top near far
光栅
	三角形顶点环绕逆时针为正向,和摄像机法线方向叉乘可以求出朝向摄像机还是背向摄像机 
	线框图扫描转换,根据直线、曲线等等相关方程算法计算像素点
	三角面扫描转换,根据pnpoly算法计算像素点在区域内还是区域外,即射线与多边形的交点是奇数还是偶数
状态
	颜色
		模式 RGBA模式 索引模式
		亮度    颜色亮度
		饱和度  颜色纯度
		混合	Additive模式(a+b)变亮 Blend模式a*alpha + b*(1-alpha)透明 正片叠底a*b变暗
				//混合
				glEnable(GL_BLEND);
				glBlendFunc(GL_ONE,GL_ONE); GL_ZERO GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
		空间	GAMMA空间&LINER空间
				现实中几乎所有图片默认都是存储为GAMMA格式,即经过0.45gamma纠正 
			  	显示器又做了2.2的逆向纠正,使得最终结果保持一致
			  	光照计算是线性的,因此输入图片是线性的跨平台才能更精确
				UNITY中sRGB选项表示该图片是GAMMA图片,注意:Default格式才有这个选项
				LINER需要OPENGLES3.0支持
		HDR		
				光的颜色分量是8位,最多0-255,大部分高亮的颜色都超过了255
				人眼瞳孔会根据光线射入量进行自适应调节,太亮时缩小瞳孔减少射入量,太暗放大增加射入量
				不开启HDR选项的摄像机拍摄的图片,亮度会被裁剪到0-255,光照强度*颜色超过255会被削减
				从室内观察室外和从室外观察明暗变化
				游戏中使用HDR算法模拟人眼瞳孔的自适应,根据平均亮度自动调整
				unity开启hdr选项会增加一个hdr buffer,存储超过1的颜色
		清理    摄像机的清理选项一般包括:天空盒、固定颜色、深度、不清理 	
				glClearColor*() 设置摄像机的颜色缓存清理颜色值
				glClearDepth(1);
				glClearStencil(0); 
				glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT)			
		透明度测试 比较当前像素与测试像素值,根据比较类型过滤
				glEnable(GL_ALPHA_TEST);
				glAlphaFunc(GL_GREATER,0);
				glDisable(GL_ALPHA_TEST);
		模板测试
				glEnable(GL_STENCIL_TEST);
				glStencilFunc(GL_GREATER,ref,mask);
				glStencilOp(模板未通过,模板通过深度未通过,都通过);
				glDisable(GL_STENCIL_TEST);
		深度测试  比较当前像素与目标像素深度,根据比较类型过滤 
				glDepthMask(1)设置是否开启ZWrite
				glEnable(GL_DEPTH_TEST);
				glDepthFunc(GL_GREATER);
				glDisable(GL_DEPTH_TEST);

				深度测试存在误差,两帧测试结果可能不一样
				GL_POLYGON_OFFSET_FILL
				使用glPolygonOffset(1,1)绘制穿插的背景
					glPolygonOffset(-1,-1)绘制穿插的前景
		背面消除
				glEnable(GL_CULL_FACE)
				glCullFace(GL_BACK)
				glDisable(GL_CULL_FACE);
		雾效果
				glEnable(GL_FOG)
				glFog*(GL_FOG_START,MIN)
				glDisable(GL_FOG);
颜色模型
		RGB模型,通过RGB三基色来调节颜色
		HSV模型,通过色调、亮度、饱和度来调节颜色
		RGB和HSV可以通过公式进行转换
窗口
	去除CMD窗口 #pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"")
	获取屏幕   glutGet(GLUT_SCREEN_WIDTH) GLUT_SCREEN_HEIGHT
	创建父窗口 glutCreateWindow(name) glutInitWindowSize(); glutInitWindowPosition();
	创建子窗口 glutCreateSubWindow(parent,x,y,w,h);
	删除子窗口 glutDestroyWindow(wID);
	当前窗口   glutG/SetWindow(wID);
	交换帧缓存 glutSwapBuffers();
	窗口全屏   glutFullScreen();
	窗口大小   glutReshapeWindow(w,h) glutPositionWindow(x,y);
	输入回调   glutMouseFunc(void (*func) (int button, int state, int x, int y)); 鼠标
			   glutKeyboardFunc(void (*func) (unsigned char key, int x, int y) ); 键盘
			   glutMotionFunc(void (*func)(int x, int y));  按下移动
			   glutPassiveMotionFunc(void (*func)(int x, int y)); 普通移动
			   glutEntryFunc(void (*func) (int state)); 鼠标进出窗口
传输顶点
	单个传输 glBegin glEnd之间通过glVertex*一个一个的设置
			 效率贼低
			 OpenGL3.0 已废弃
	显示列表 提前设置好顶点信息,传给GPU之后无法修改
			 应用: 矩阵操作 材质定义 纹理定义 光照定义
			 创建显示列表 GLuint id = glGenLists(1);
			 			  glNewList(id,GL_COMPILE);
			 			  glEndList();
			 绘制显示列表 glCallList(id);
			 删除显示列表 glDeleteLists(id,1);
	顶点数组 提前设置好顶点信息,传给GPU之后可以修改
			 顶点数据在内存中,每次绘制时都需要传输给GPU
			 启用/禁用数组 glEnableClientState() glDisableClientState()
			 指定数组位置 glVertexPointer glNormalPointer glColorPointer glIndexPointer glTexCoordPointer 
			 传输顶点数组 glDrawArrays(GL_TRIANGLES, 0, 36)  直接绘制顶点数组
			 			  glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_BYTE, ptr); 绘制索引数组
	以上三种方式均已过时
	VBO     顶点数组的升级版本,在显存内申请一块内存,存储顶点相关信息
			可以通过一些API修改这个数据
			创建显存对象 Gluint vboID;glGenBuffers(1,&vboID);
			绑定对象类型 glBindBuffer(GL_ARRAY_BUFFER,vboID);
						GL_ELEMENT_ARRAY_BUFFER 索引缓冲VBO
						GL_ARRAY_BUFFER 顶点缓冲VBO
			设置对象属性  glBufferData(GL_ARRAY_BUFFER,数组内存大小,数组指针,存储方式); 
					    glBufferSubData(GL_ARRAY_BUFFER,对象偏移,数组长度,数组指针);
						static  一次指定多次使用,适用于静态物体
						dynamic 反复指定反复使用,适用于动态物体
						stream  一次指定一次使用,每帧都会变化
						draw 表示对象被用来绘制使用
						read 表示对象被用来读取使用
						copy
			绘制缓存数据  
						开启attrib
						gl*AttribPointer  定义VBO顶点、颜色、法线、UV格式
						glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_BYTE, 0); 绘制索引VBO
						关闭attrib
			映射显存对象
						 void* glMapBuffer(GL_ARRAY_BUFFER,GL_READ_WRITE);可以映射显存	  
						 glUnmapBuffer(GL_ARRAY_BUFFER)取消映射 
			删除缓存数组 glDeleteBuffers(vboID);
	VAO
			存储了VBO的引用和顶点属性格式,VAO本身不存储顶点数据
			绑定VAO之后 后续创建的VBO都属于当前VAO
			创建VAO glGenVertexArray()
			绑定VAO glBindVertexArray()
			使用VAO之后,后续创建的VBO EBO只需要bindvao就可以绘制了
	静态合批
		创建一个大的VBO存储顶点,不同的IBO存储索引,每次绘制只绘制单个IBO(索引大的VBO上的一段)
		静态合批的对象是共享相同材质球的
	动态合批
		CPU动态检测相同材质的MESH,合并成一个VBO,合并有顶点数限制
	vertex constant instancing
		对于模型一致的物体,只提交原始模型给GPU,其他属性单独构成BUFFER提交给GPU
	GPU INSTANCE
		大量物体只提交一个原始模型给GPU,其他属性交给SHADER来处理
		drawmesh(instanced) 代表被GPU INSTANCE
		unity默认只对相同MESH相同材质 不同位置、缩放、旋转的物体进行GPU INSTANCE
			受不同实时灯光或者处于不同光照贴图的也不会被合批
		其他属性需要自己在shader内添加
			C#  
				创建实例变量
				MaterialPropertyBlock
			shader
				标记编译生成实例变量
				#pragma multi_compile_instancing 
				定义实例ID
				UNITY_VERTEX_INPUT_INSTANCE_ID   
				UNITY_SETUP_INSTANCE_ID
				UNITY_TRANSFER_INSTANCE_ID
				定义实例变量
		       	UNITY_INSTANCING_BUFFER_START(Props)
	           		UNITY_DEFINE_INSTANCED_PROP(fixed4, _Color)
	        	UNITY_INSTANCING_BUFFER_END(Props)
	        	获取实例变量
	        	UNITY_ACCESS_INSTANCED_PROP(Props, _Color)
纹理贴图
	帧缓存 
		设置接下来要读取的缓存类型
		glReadBuffer(GL_FRONT) 默认读取后缓存GL_BACK
		读取缓存数据
		glReadPixels(x,y,w,h,GL_RGBA,GL_UNSIGNED_BYTE,ptr)
		屏蔽帧缓存
		glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_FALSE) glDepthMask(GL_FALSE) glStencilMask()
		从帧缓存拷贝图片到当前纹理
		glCopyTexImage2D(GL_TEXTURE_2D,mipmapLevel,GL_RGBA,x,y,w,h,0);
	纹理载入
		从指定位置读取纹理数据到当前指定的纹理
			创建纹理对象
				GLuint texID;
				glGenTexture(1,&texID);   
			设置纹理对象类型
			glBindTexture(GL_TEXTURE_2D,texID) 
			设置纹理过滤类型
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINER);
			读取纹理数据
			glTexImage2D(GL_TEXTURE_2D,mipmapLevel,GL_RGBA,宽,高,0,0,GL_RGBA,GL_UNSIGNED_BYTE,PTR);
			替换纹理数据
			glTexSubImage2D(GL_TEXTURE_2D,mipmapLevel,x,y,宽,高,GL_RGBA,GL_UNSIGNED_BYTE,PTR);
			删除纹理对象
			glDeleteTextures(1,&texID);
		纹理过滤
			当纹理和多边形光栅后的片段像素无法完全匹配时,纹理会被拉伸或者收缩
			根据一个经过拉伸的贴图计算顶点颜色的过程称为纹理过滤
			GL_TEXTURE_MAG_FILTER 指定放大时如何过滤
			GL_TEXTURE_MIN_FILTER 指定缩小时如何过滤
			GL_LINER 线性过滤 双线性过滤
			GL_NEAREST 最近点过滤 各向异性过滤
			最近点过滤 采样1次
			双线性 采样4次
				在同一个mipmap下采样
			三线性 采样8次
				在同一个mipmap下采样后再相邻的mipmap采样
			各向异性过滤 简称AF, 4x采样32次,16x采样128次
				贴图贴到平行于摄像机的面时各向同性,否则是各项异性
				考虑贴图的面与屏幕的倾斜角度
		纹理环绕
			纹理坐标大于1或者小于0时如何采样
			以上两种一般选取线性、重复模式
		MipMap 
			硬件支持生成MIPMAP
			glGenerateMipmap(GL_TEXTURE_2D);
建模
	Mesh  由点、面、法线、切线、颜色等5个基本数组构成
	MeshRender
		  灯光: 阴影、光照贴图
		  材质: 根据submesh数量,每个submesh对应一个材质
	AnimationClip
		  记录了骨骼或者顶点的运动曲线(由关键帧组成),根据动画时间差值计算当前状态
着色器
    分类
    	一种是在Edit->ProjectSettings->GraphicsSetting内设置和放在Resources文件夹内的shader,使用shader.find查找
    	一种是使用打包后Load出来的shader
光照系统
		光照计算			
		    需要光源强度、方向、颜色,然后根据光照模型方程计算光照
		光源类型 
			平行光 点光源 聚光灯 环境光 面光源 
			反射球 发光球  
		光照模型
		光线跟踪
		渲染路径
		透明模型
		雾气效果
		实时阴影
			以光源为视点渲染一张深度纹理,即ShadowMap
			渲染接受阴影的物体,将物体由模型空间转换至灯光空间,采样深度纹理,比较深度值,大于采样深度则为阴影
		光照贴图
		光照设置
			环境光 实时光 混合光 光照贴图 其它设置 调试设置
粒子系统
动画系统
	所有的动画都是基于关键帧的,每帧采样,中间帧经过插值生成
	UV动画 在SHADER内根据时间计算图片的UV坐标
	帧动画 一张一张的图片,每张图片是一个关键帧
	骨骼动画 模型由骨骼、MESH构成,动画控制骨骼运动,MESH根据依赖的骨骼及其权重计算位置
			 Rig 
			 蒙皮 美术对MESH顶点的依赖骨骼指定的过程
			 蒙皮计算 骨骼运动后,根据蒙皮矩阵计算顶点位置
			 BindPos MESH顶点从模型坐标系转换至世界坐标系在转换至骨骼坐标系
			 		 每次运动根据骨骼位置计算出绑定姿势下的顶点位置,在转换至模型坐标系
			 IK逆向动力学 子物体影响父物体
			 FK正向动力学 父物体影响子物体
	动画融合 连续播放的两个动画衔接的过程
	动画混合 同时播放的两个动画衔接的过程
	GPU蒙皮  MESH顶点计算转移到shader内
	Animation Instancing
		减少Animator.Update开销
		减少MeshSkining.Update开销
		减少CPU到GPU的数据传输
		不支持BlendTree
		不支持IK
		动画精确性降低
