2D碰撞检测    利用四叉树管理场景,快速找出和目标对象相交的树结点,然后利用2D图形碰撞检测,找出相交的图形
                  优化:对象只存储在完全包含该对象的结点内,减少存储次数和遍历次数
              点到平面距离: 根据两点求出法向量,根据法向量和点求出距离
              分离轴算法: 取凸多边形a的每条边的法线(即分离轴),计算A和B的所有顶点在法线上的投影(记录边界点),有间隙则不相交    
                          线段法线 线段顺时针旋转90度, n = bz - az,0, -(bx-ax)  
                          线段投影 计算顶点投影覆盖范围,有交点那么一定相交  rmin = rmax = dot(axis,v);  
              圆形和矩形: 计算V向量(矩形中心指向圆心P,并且x、y都取绝对值) U向量(V-H(矩形中心指向右上角顶点))(x、y取第一象限的值),计算U向量和圆半径大小
                          vector2 v = abs(p-c);
                          vector2 u = max(v-h,vector2.zero);
                          return u * u <= r * r;
              圆形和圆形: 判断圆心距离和半径之和的大小
                          return vector2.distance(p1,p2) <= r1 + r2;
              圆形和扇形: 圆和圆相交
                          圆心是否在扇形角度内
                          圆和线段是否相交                              
              圆形和胶囊: 圆和线段是否相交
              圆形和三角: 面积法判断点是否在凸多边形内
                          pnpoly算法判断点在多边形内
                          判断圆与线段是否相交
              线段和线段: AB与CD相交,那么AB两点在CD线段两侧并且CD两点在线段AB两侧,利用叉乘求法线方向
                          3D的话,在计算三角形ACB和ACD的法线单位化后是否相同
              线段和凸多边形: pnpoly算法或者面积法判断点在多边形内
                              线段与线段是否相交
              点和凸多边形: 点和各个边顶点构成的三角形面积之和等于多边形的面积                                  
                            pnpoly算法判断点在内部
              凸多边形和凸多边形: 使用分离轴定理快速检查是否相交
              pnpoly算法: (yj > yp != yi > yp) && (xp < (xj - xi) * (yp - yi) / (yj -yi) + xi)

              两个点是否在线段同侧: 三角形ABC和点P,(ABxAP)*(ABxAC) > 0 ? true : false; 法线同向则夹角为0
              三角形内的点,使用向量加法可以写为,求出质心坐标(u,v),三角形内的点满足(u >= 0) && (v >= 0) && (u + v < 1)  
                    AP = u * AB + v * BC
                    两边同时分别乘以AB和BC, 联立方程求解得出u和v    
                    根据向量乘法计算出u,v
                    克莱姆法则
              任意点是否在凸多边形内都可以采用pnpoly算法或者求解质心坐标的方式
              点到线段的距离
                    先通过计算AB*AP求出夹角是锐角还是钝角,然后判断APcos∠PAB大小,也就是P点在线段AB上的投影点clamp到0,1
                    然后根据向量加法PA + t*AB = P'P得出垂线段向量,t是0那么就是A点,t是1就是B点
                    t = PA * AB / ab
3D碰撞检测     需要针对大场景构建AABB树
              根据场景大小构建一个大的AABB,循环添加场景对象,
              从根节点开始查找能够完全包含当前AABB对象的盒子,如果当前结点能够包含,继续扩展八等分子节点,遍历子节点执行包含检测
              当动态物体运动时,先修改结点标记,然后重新执行一次插入操作
              八叉树和四叉树都可以用于快速查找目标对象(例如快速查找子弹碰到了谁)
碰撞检测算法
              精细的碰撞检测需要对物体建模,构建一个凸包围体,然后执行凸包围体之间的相交测试
              最精细的检测是最所有的面检查碰撞
              可以利用凸体的一些算法简化计算量
              利用AABB、八叉树、四叉树简化计算范围
凸包围体
              2D,andrew算法创建模型的凸包围体
              3D,quickhull算法创建模型的凸包围体
闵可夫斯基和
              两个点集A和B,C是minkosiki和,那么C=A+B,A中所有顶点加上B中所有顶点构成的集合
              顶点集A和B发生碰撞,那么C包含原点
              A和B的最短距离等价于C和原点的最短距离
粗略测试阶段
            粒子,相交测试,粒子可以简化为一个点,判断点在多边形内还是外部即可
            AABB包围盒,相交测试,已知AABB最大和最小顶点,优化:优先比较xz平面 
                    a.minx > b.maxx || a.maxx < b.minx 
                    a.miny > b.maxy || a.maxy < b.miny 
                    a.minz > b.maxz || a.maxz < b.minz
            AABB包围球,相交测试,已知半径和中心点
                    (a-b)^2 > (ar + br)^2
精确测试阶段