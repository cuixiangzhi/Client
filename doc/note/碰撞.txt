2D碰撞检测    利用四叉树管理场景,快速找出和目标对象相交的树结点,然后利用2D图形碰撞检测,找出相交的图形
                  优化:对象只存储在完全包含该对象的结点内,减少存储次数和遍历次数
              点到平面距离: 根据两点求出法向量,根据法向量和点求出距离
              分离轴算法: 取凸多边形a的每条边的法线(即分离轴),计算A和B的所有顶点在法线上的投影(记录边界点),有间隙则不相交    
                          线段法线 线段顺时针旋转90度, n = bz - az,0, -(bx-ax)  
                          线段投影 计算顶点投影覆盖范围,有交点那么一定相交  rmin = rmax = dot(axis,v);  
              圆形和矩形: 计算V向量(矩形中心指向圆心P,并且x、y都取绝对值) U向量(V-H(矩形中心指向右上角顶点))(x、y取第一象限的值),计算U向量和圆半径大小
                          vector2 v = abs(p-c);
                          vector2 u = max(v-h,vector2.zero);
                          return u * u <= r * r;
              圆形和圆形: 判断圆心距离和半径之和的大小
                          return vector2.distance(p1,p2) <= r1 + r2;
              圆形和扇形: 圆和圆相交
                          圆心是否在扇形角度内
                          圆和线段是否相交                              
              圆形和胶囊: 圆和线段是否相交
              圆形和三角: 面积法判断点是否在凸多边形内
                          pnpoly算法判断点在多边形内
                          判断圆与线段是否相交
              线段和线段: AB与CD相交,那么AB两点在CD线段两侧并且CD两点在线段AB两侧,利用叉乘求法线方向
              线段和凸多边形: pnpoly算法或者面积法判断点在多边形内
                              线段与线段是否相交
              点和凸多边形: 点和各个边顶点构成的三角形面积之和等于多边形的面积                                  
                            pnpoly算法判断点在内部
              凸多边形和凸多边形: 使用分离轴定理快速检查是否相交
              pnpoly算法: (yj > yp != yi > yp) && (xp < (xj - xi) * (yp - yi) / (yj -yi) + xi)

              两个点是否在线段同侧: 三角形ABC和点P,(ABxAP)*(ABxAC) > 0 ? true : false; 法线同向则夹角为0
              三角形内的点,使用向量加法可以写为  
                    AP = u * AB + v * BC, 两边同时分别乘以AB和BC, 联立方程求解得出u和v                               
                    // Compute vectors        
                    v0 = C - A
                    v1 = B - A
                    v2 = P - A
                    // Compute dot products
                    dot00 = dot(v0, v0)
                    dot01 = dot(v0, v1)
                    dot02 = dot(v0, v2)
                    dot11 = dot(v1, v1)
                    dot12 = dot(v1, v2)
                    // Compute barycentric coordinates
                    invDenom = 1 / (dot00 * dot11 - dot01 * dot01)
                    u = (dot11 * dot02 - dot01 * dot12) * invDenom
                    v = (dot00 * dot12 - dot01 * dot02) * invDenom
                    // Check if point is in triangle
                    return (u >= 0) && (v >= 0) && (u + v < 1)
              点到线段的距离
                    先通过计算AB*AP求出夹角是锐角还是钝角,然后判断APcos∠PAB大小,也就是P点在线段AB上的投影点clamp到0,1
                    然后根据向量加法PA + t*AB = P'P得出垂线段向量,t是0那么就是A点,t是1就是B点
3D碰撞检测     需要针对大场景构建AABB树
              根据场景大小构建一个大的AABB,循环添加场景对象,
              从根节点开始查找能够完全包含当前AABB对象的盒子,如果当前结点能够包含,继续扩展八等分子节点,遍历子节点执行包含检测
              当动态物体运动时,先修改结点标记,然后重新执行一次插入操作
              八叉树和四叉树都可以用于快速查找目标对象(例如快速查找子弹碰到了谁)
GJK算法  