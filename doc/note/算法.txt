MD5     生成16字节128位的数,每次处理512位64字节的数据,处理完后更新128位数据,不够64字节补1+0,最后生成128位MD5码
UUID    MD5长度128位,UUID是128位数的16进制表示的字符串,格式08-04-04-04-0804
HAFMAN  单个字符出现频率编码,由原始的不同的字符出现的次数为权值,构造哈夫曼树,每个字符有一条路径构成的编码
LZ77    字典模型,首先有一个字典表,包含了出现过的单词或者句子,再次出现时只有一个位置索引即可
        滑动窗口,即字典,字典查找过程就是查找最大子串
加密    基于异或运算的位加密算法,A^B=C C^B=A
BASE64  HTTP请求发送数据只能发送ASCII码,因此需要进行编码操作

路点寻路算法
        缺点:无法动态规避障碍、无法标记角色信息、无法标记地形信息、路径不平滑
导航寻路算法
        1.生成导航网格

        2.导航网格寻路
            启发式搜索算法A*搜索最优多边形路径,结果是一个连续邻接的多边形(多边形有可能是跳转点,即OffMeshLink)
                F = G + H
                首先根据当前位置找出所在多边形A,目标位置所在多边形B(这里的多边形都是可行走的,不可行走的在生成阶段已被剔除)
                    创建目标包围盒
                    根据bmin和bmax获取所属tile位置
                    根据tile位置获取tile,
                    根据tile获取tile内多边形的包围盒(包围盒数组是一个排好序的数组,负数代表包围盒右子节点的偏移)
                    根据包围盒二分树判断是否包含目标包围盒并且是叶节点
                    根据找出来的多边形和目标位置,找出一个距离目标多边形最近的点或者包含在多边形内
                检查AB是否合法,AB是否相等,相等则直接返回A多边形引用,路径长度为1
                OPEN表清空
                新建NODE FOR A,消耗为0,H值为直线距离乘以缩放因子(控制是否找出最优路径,小于0一定是最优的),加入OPEN表
                循环(OPEN表非空)                 
                    取头结点,更改结点状态为CLOSED,不修改父结点状态,是目标?结束循环:继续
                    取出当前tile和poly和它的父结点
                        遍历当前结点可行走的邻接多边形,新结点?取邻接边中点赋值
                        计算消耗,当前邻接结点是目标多边形?F = 1当前结点cost(已花费) + 2当前结点pos到中点消耗 + 3中点到目标点消耗 + 0 : 1 + 2 + H
                        当前邻接结点在OPEN表内并且总消耗小于当前消耗?修改OPEN表内该结点消耗:加入OPEN表(会排序),当前最优点消耗小于已知最优点?更新最优点
                最优点不等于目标点?只找出了部分路径
                从最优点开始,找出父结点连接的路径,存储到PATH数组内
            拐点法寻找最优路点路径
                1.首先找到起始多边形和穿出边的两个端点,连线L、R
                2.找出下一个穿出边左点,连线L',判断L'是否在L、R之间,如果在,则L更新为L',同理找出右点,连线R',判断R'是否在L、R之间,如果在,则R更新为R'
                如果L'R'都在L左侧或者R右侧,则L或R为一个拐点
                3.继续找出下一个拐点,直到目标多边形
            射线法判断目标点是否直接可达
                1.遍历初始多边形每条边,判断与射线AB是否相交(判断AOP BOP是否同向,同向不相交)
                2.通过穿出边找出下一个多边形,继续上述判断,直到碰到不可穿出区域或者到达目标区域

