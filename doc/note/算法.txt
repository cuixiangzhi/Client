MD5     生成16字节128位的数,每次处理512位64字节的数据,处理完后更新128位数据,不够64字节补1+0,最后生成128位MD5码
UUID    MD5长度128位,UUID是128位数的16进制表示的字符串,格式08-04-04-04-0804
HAFMAN  单个字符出现频率编码,由原始的不同的字符出现的次数为权值,构造哈夫曼树,每个字符有一条路径构成的编码
LZ77    字典模型,首先有一个字典表,包含了出现过的单词或者句子,再次出现时只有一个位置索引即可
        滑动窗口,即字典,字典查找过程就是查找最大子串
加密    基于异或运算的位加密算法,A^B=C C^B=A
BASE64  HTTP请求发送数据只能发送ASCII码,因此需要进行编码操作

碰撞检测
        分离轴算法: 取凸多边形a的每条边的法线,计算A和B的所有顶点在法线上的投影,都不相交则不相交
        圆形和矩形、圆形和圆形、球形和长方体、球形和圆柱体、长方体和圆柱体
        格子:   每个物体占用NxN个格子,判断格子是否相交,算法复杂度(N-1)!
        四叉树: 划分2D地图为四叉树,降低计算复杂度,主要是避免两两全部比较,位置改变时就同步其所在的四叉树位置
        八叉树: 四叉树在3D场景中的扩展
        包围盒: 快速粗略检测碰撞或者快速定位点所属的多边形(在导航网格中应用到了)
路点寻路算法
        优点:快速实现,简单,路径顺眼
        缺点:无法动态规避障碍、无法标记角色信息、无法标记地形信息、路径不平滑
导航寻路算法
        1.生成导航网格 

        2.导航网格寻路
            启发式搜索算法A*
                F = G + H
                首先根据当前位置找出所在多边形A,目标位置所在多边形B(这里的多边形都是可行走的,不可行走的在生成阶段已被剔除)
                    创建目标包围盒
                    根据bmin和bmax获取所属tile位置
                    根据tile位置获取tile,
                    根据tile获取tile内多边形的包围盒(包围盒数组是一个排好序的数组,负数代表包围盒右子节点的偏移)
                    根据包围盒二分树判断是否包含目标包围盒并且是叶节点
                    根据找出来的多边形和目标位置,找出一个距离目标多边形最近的点或者包含在多边形内
                检查AB是否合法,AB是否相等,相等则直接返回A多边形引用,路径长度为1
                OPEN表清空
                新建NODE FOR A,消耗为0,H值为直线距离乘以缩放因子(控制是否找出最优路径,小于0一定是最优的),加入OPEN表
                循环(OPEN表非空)                 
                    取头结点,更改结点状态为CLOSED,不修改父结点状态,是目标?结束循环:继续
                    取出当前tile和poly和它的父结点
                        遍历当前结点可行走的邻接多边形,新结点?取邻接边中点赋值
                        计算消耗,当前邻接结点是目标多边形?F = 1当前结点cost(已花费) + 2当前结点pos到中点消耗 + 3中点到目标点消耗 + 0 : 1 + 2 + H
                        当前邻接结点在OPEN表内并且总消耗小于当前消耗?修改OPEN表内该结点消耗:加入OPEN表(会排序),当前最优点消耗小于已知最优点?更新最优点
                最优点不等于目标点?只找出了部分路径
                从最优点开始,找出父结点连接的路径,存储到PATH数组内
            拐点法寻找最优路点路径
                1.首先找到起始多边形和穿出边的两个端点,连线L、R
                2.找出下一个穿出边左点,连线L',判断L'是否在L、R之间,如果在,则L更新为L',同理找出右点,连线R',判断R'是否在L、R之间,如果在,则R更新为R'
                如果L'R'都在L左侧或者R右侧,则L或R为一个拐点
                3.继续找出下一个拐点,直到目标多边形
            射线法判断目标点是否直接可达
                1.遍历初始多边形每条边,判断与射线AB是否相交(判断AOP BOP是否同向,同向不相交)
                2.通过穿出边找出下一个多边形,继续上述判断,直到碰到不可穿出区域或者到达目标区域
AOI:     主要是为了避免场景内对象频繁移动导致推送数据量过大,只推送给AOI半径范围内的实体
         具体实现可以采用八叉树(二叉树)场景划分管理,每个结点是一个立方体的格子
状态同步: 随机种子: 随机种子需要服务器生成返回给客户端
         发送指令: 客户端发送点击指令给服务器,同时客户端开始执行表现
         同步状态: 服务器把每个客户端的状态反馈的一定区域内的玩家
         延迟补偿: 服务器根据传输延迟做补偿,例如服务器对技能时间补偿
                  客户端需要对技能更新时间做补偿,因为技能每次更新的间隔不稳定、其它客户端收到状态变化有延迟
锁定同步: 初始化帧: 所有战斗单位进入第一帧,随机种子保持一致,这样所有玩家的逻辑状态是完全一致的
         等待输入: 锁定同步算法会导致一人延迟卡住,其它人也跟着卡住
         同步输入: 每一帧的逻辑时间是固定的,所以输入一致,那么所有人的逻辑状态也是一致的
         战斗模拟: 需要实现一个与表现完全分离的战斗模拟器,服务器可以利用该模拟器进行模拟验证,客户端使用该模拟器同步逻辑状态
乐观同步: 初始化帧: 和锁定同步一样
         定时采集: 服务器定时采集所有客户端的输入(摇杆移动也是输入的移动指令,定时时间延迟是否会感觉到?)
         定时发送: 服务器同步每个定时间隔内的输入给所有客户端
         战斗模拟: 和锁定同步一样
         网络要求: 40ms以内应该是比较流畅


