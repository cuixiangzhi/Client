MD5     生成16字节128位的数,每次处理512位64字节的数据,处理完后更新128位数据,不够64字节补1+0,最后生成128位MD5码
UUID    MD5长度128位,UUID是128位数的16进制表示的字符串,格式08-04-04-04-0804
HAFMAN  单个字符出现频率编码,由原始的不同的字符出现的次数为权值,构造哈夫曼树,每个字符有一条路径构成的编码
LZ77    字典模型,首先有一个字典表,包含了出现过的单词或者句子,再次出现时只有一个位置索引即可
        滑动窗口,即字典,字典查找过程就是查找最大子串
加密    基于异或运算的位加密算法,A^B=C C^B=A
BASE64  HTTP请求发送数据只能发送ASCII码,因此需要进行编码操作

立体几何

轨迹方程
        平面:  Ax+By+Cz+D = 0
        直线:  两平面交点 起点+方向
        圆:    圆心+法线+半径
        斜抛:  分解为水平运动和垂直运动,计算出水平初始速度和垂直初始速度,vt-1/2gt^2 vt
        外心:  三角形外接圆圆心,垂直平分线交点
        内心:  三角形内接圆圆心,内角平分线交点
        重心:  三角形中线交点,满足定点到质心距离:质心到中点距离=2:1
向量叉乘 axb = (a.yb.z - a.zb.y,a.zb.x - a.xb.z,a.xb.y - a.yb.x)
         如果是2D向量相乘,那么2D向量所在的两个分量结果一定为0,结果为三角形面积,法线长度
射影定理 三角形垂线分割边为ADDB, 那么CD * CD = AD * DB
         AC = BC * cos∠BAC + AB * cos∠BCA; 
线面夹角 范围是0-90
海伦公式 三角形面积s^2 = p(p-a)(p-b)(p-c)

场景管理 四叉树: 2D场景对象管理
               构建
                  扩展场景大小为正方形,创建根结点
                  遍历场景对象
                            从根结点开始查找能够完全包含该AABB对象的结点
                            扩展结点(添加四个子结点),检查子结点是否完全包含对象,包含则继续扩展结点
                  一颗四叉树就构建完成了
                用途
                   1.遮挡剔除  筛选出与视椎体相交的结点,结点内的对象就是需要渲染的对象
                   2.碰撞检测  筛选出与特殊对象相交的对象
        八叉树: 3D场景对象管理,是四叉树在三维上的应用
        BSP树:  适用于互相遮挡比较多的室内场景,而四叉树和八叉树适用于开阔的室外场景
        包围树: 计算出所有凸多边形的AABB,先构建根结点AABB,包含所有的凸多边形,然后沿着最长的轴排序,划分左右子树,然后递归构建左右子树
               叶节点是具体的多边形,非叶子结点是完全包含左右子树的AABB，并且记录了其右兄弟结点的偏移值
碰撞检测
        2D碰撞检测    利用四叉树管理场景,快速找出和目标对象相交的树结点,然后利用2D图形碰撞检测,找出相交的图形
                          优化:对象只存储在完全包含该对象的结点内,减少存储次数和遍历次数
                      点到平面距离: 根据两点求出法向量,根据法向量和点求出距离
                      分离轴算法: 取凸多边形a的每条边的法线(即分离轴),计算A和B的所有顶点在法线上的投影(记录边界点),有间隙则不相交    
                                  线段法线 线段顺时针旋转90度, n = bz - az,0, -(bx-ax)  
                                  线段投影 计算顶点投影覆盖范围,有交点那么一定相交  rmin = rmax = dot(axis,v);  
                      圆形和矩形: 计算V向量(矩形中心指向圆心P,并且x、y都取绝对值) U向量(V-H(矩形中心指向右上角顶点))(x、y取第一象限的值),计算U向量和圆半径大小
                                  vector2 v = abs(p-c);
                                  vector2 u = max(v-h,vector2.zero);
                                  return u * u <= r * r;
                      圆形和圆形: 判断圆心距离和半径之和的大小
                                  return vector2.distance(p1,p2) <= r1 + r2;
                      圆形和扇形: 圆和圆相交
                                  圆心是否在扇形角度内
                                  圆和线段是否相交                              
                      圆形和胶囊: 圆和线段是否相交
                      圆形和三角: 面积法判断点是否在凸多边形内
                                  pnpoly算法判断点在多边形内
                                  判断圆与线段是否相交
                      线段和线段: AB与CD相交,那么AB两点在CD线段两侧并且CD两点在线段AB两侧,利用叉乘求法线方向
                      线段和凸多边形: pnpoly算法或者面积法判断点在多边形内
                                      线段与线段是否相交
                      点和凸多边形: 点和各个边顶点构成的三角形面积之和等于多边形的面积                                  
                                    pnpoly算法判断点在内部
                      凸多边形和凸多边形: 使用分离轴定理快速检查是否相交
                      pnpoly算法: (yj > yp != yi > yp) && (xp < (xj - xi) * (yp - yi) / (yj -yi) + xi)

                      两个点是否在线段同侧: 三角形ABC和点P,(ABxAP)*(ABxAC) > 0 ? true : false; 法线同向则夹角为0
                      三角形内的点,使用向量加法可以写为  
                            AP = u * AB + v * BC, 两边同时分别乘以AB和BC, 联立方程求解得出u和v                               
                            // Compute vectors        
                            v0 = C - A
                            v1 = B - A
                            v2 = P - A
                            // Compute dot products
                            dot00 = dot(v0, v0)
                            dot01 = dot(v0, v1)
                            dot02 = dot(v0, v2)
                            dot11 = dot(v1, v1)
                            dot12 = dot(v1, v2)
                            // Compute barycentric coordinates
                            invDenom = 1 / (dot00 * dot11 - dot01 * dot01)
                            u = (dot11 * dot02 - dot01 * dot12) * invDenom
                            v = (dot00 * dot12 - dot01 * dot02) * invDenom
                            // Check if point is in triangle
                            return (u >= 0) && (v >= 0) && (u + v < 1)
                      点到线段的距离
                            先通过计算AB*AP求出夹角是锐角还是钝角,然后判断APcos∠PAB大小,也就是P点在线段AB上的投影点clamp到0,1
                            然后根据向量加法PA + t*AB = P'P得出垂线段向量,t是0那么就是A点,t是1就是B点


        3D碰撞检测     需要针对大场景构建AABB树
                      根据场景大小构建一个大的AABB,循环添加场景对象,
                      从根节点开始查找能够完全包含当前AABB对象的盒子,如果当前结点能够包含,继续扩展八等分子节点,遍历子节点执行包含检测
                      当动态物体运动时,先修改结点标记,然后重新执行一次插入操作
                      八叉树和四叉树都可以用于快速查找目标对象(例如快速查找子弹碰到了谁)
        遮挡剔除       先把场景构建成八叉树或者BSP树,然后判断视椎体和树结点是否相交,筛选出与视椎体相交的结点内的对象,也就是
GJK算法  

路点寻路
        优点:快速实现,简单,路径顺眼
        缺点:无法动态规避障碍、无法标记角色信息、无法标记地形信息、路径不平滑
导航寻路
        1.生成导航网格 
            概念
                高度场(HeightField) 根据cell(一般为0.2,0.2,0.2)大小在xyz三个方向切割,由体素构成的对象
                体素(Span) 三维空间的像素
                开放区间(CompactSpan) 垂直方向一列相邻实心体素的集合
                闭合区间(CompactCell) 垂直方向一列相邻空心体素的集合
                压缩的高度场(CompactHeightfield) 由开放区间和闭合区间构成
                层级的高度场(HeightfieldLayerSet)
                轮廓
                凸多边形
                细节多边形
            实现
                加载网格信息,每行不是v就是f,v代表一个顶点,f代表三角形,针对每个三角形创建AABB包围盒,然后创建二叉搜索树
                初始化配置信息,角色半径、CELL大小、可行走角度、可跨越高度,计算出有多少体素
                创建高度场,仅包含空的span数组,体素个数即XZ大小和AABB
                创建可行走标记数组,遍历所有的三角形,根据可行走角度以及法线,标记可行走的三角形
                光栅化 计算三角形AABB
                       在xz平面切割三角形(切割过程新增切割点),y方向是连续的,切割后是一个实心体素集(Span)
                       检查当前列是否有Span,如果有就合并,合并时根据Climp大小标记区域可行走性质
                过滤可行走体素 根据角色脚步来过滤y方向(此时不能保证相邻的体素限制角色高度)
                过滤可行走体素 根据角色脚步和角色高度来过滤xz方向
                过滤可行走体素 根据角色半径来过滤无法站立的地方
                创建压缩的高度场 压缩到XZ平面,CompactCell为压缩后的数据,CompactSpan为压缩后的Span
                过滤可行走体素 根据体素距离边界的最小距离和角色半径*2比较,水平相邻距离为2,斜对角为3,离边界越远距离越大
                               因为默认格子大小为0.3,角色半径为0.6,也就是至少两个

        3.构造导航网格
             NavMesh由凸多边形、凸多边形三角形、OffMesh、tileLink、bvtree等构成,polyRef由tileID和polyID共同构成
        2.导航网格寻路
            寻找最近的多边形
                遍历所有的多边形,判断点是否在多边形内部(pnpoly算法)并计算与每条边的距离
                点在多边形内部则计算其高度,利用向量加法AP = u * AB + v * BC)
                不在多边形内部则返回目标点
            启发式搜索算法A*
                F = G + H
                算法简述:压入初始结点
                         循环
                            弹出第一个结点
                            遍历当前结点所有相邻结点
                                计算其COST,和当前结点比较,
                                旧结点且消耗更小或者是新结点,修改消耗及其父结点,已在OPEN表则修改其消耗,否则将其加入OPEN表
                                和当前结点比较,修改最优结点
                首先根据当前位置找出所在多边形A,目标位置所在多边形B(这里的多边形都是可行走的,不可行走的在生成阶段已被剔除)
                    创建目标包围盒
                    根据bmin和bmax获取所属tile位置
                    根据tile位置获取tile,
                    根据tile获取tile内多边形的包围盒(包围盒数组是一个排好序的数组,负数代表包围盒右子节点的偏移)
                    根据包围盒二分树判断是否包含目标包围盒并且是叶节点
                    根据找出来的多边形和目标位置,找出一个距离目标多边形最近的点或者包含在多边形内
                检查AB是否合法,AB是否相等,相等则直接返回A多边形引用,路径长度为1
                OPEN表清空
                新建NODE FOR A,消耗为0,H值为直线距离乘以缩放因子(控制是否找出最优路径,小于0一定是最优的),加入OPEN表
                循环(OPEN表非空)                 
                    取头结点,更改结点状态为CLOSED,不修改父结点状态,是目标?结束循环:继续
                    取出当前tile和poly和它的父结点
                        遍历当前结点可行走的邻接多边形,新结点?取邻接边中点赋值
                        计算消耗,当前邻接结点是目标多边形?F = 1当前结点cost(已花费) + 2当前结点pos到中点消耗 + 3中点到目标点消耗 + 0 : 1 + 2 + H
                        当前邻接结点在OPEN表内并且总消耗小于当前消耗?修改OPEN表内该结点消耗:加入OPEN表(会排序),当前最优点消耗小于已知最优点?更新最优点
                最优点不等于目标点?只找出了部分路径
                从最优点开始,找出父结点连接的路径,存储到PATH数组内
            Dijkstra算法
                1.建立二维数组V2,存储当前源点到其他点直接距离,不相邻为无穷大
                2.建立数组V1,存储源点到其他点的最短距离,长度为顶点数(多边形数),每个数组对象存储当前最短距离的父结点ID
                3.遍历每个顶点,检查经过该顶点到其他顶点的距离是否会缩短,修改其他顶点的最短距离和父结点,最终可以求出当前结点到所有点的最短距离和路径
                4.算法复杂度O(N^2)
            拐点法寻找最优路点路径
                1.首先找到起始多边形和穿出边的两个端点,连线L、R
                2.找出下一个穿出边左点,连线L',判断L'是否在L、R之间,如果在,则L更新为L',同理找出右点,连线R',判断R'是否在L、R之间,如果在,则R更新为R'
                如果L'R'都在L左侧或者R右侧,则L或R为一个拐点
                3.继续找出下一个拐点,直到目标多边形
            射线法判断目标点是否直接可达
                1.遍历初始多边形每条边,判断与射线AB是否相交(判断AOP BOP是否同向,同向不相交)
                2.通过穿出边找出下一个多边形,继续上述判断,直到碰到不可穿出区域或者到达目标区域
区域同步:主要是为了避免场景内对象频繁移动导致推送数据量过大,只推送给AOI半径范围内的实体
         具体实现可以采用八叉树(二叉树)场景划分管理,每个结点是一个立方体的格子
状态同步: 随机种子: 随机种子需要服务器生成返回给客户端
         发送指令: 客户端发送点击指令给服务器,同时客户端开始执行表现
         同步状态: 服务器把每个客户端的状态反馈的一定区域内的玩家
         延迟补偿: 服务器根据传输延迟做补偿,例如服务器对技能时间补偿
                  客户端需要对技能更新时间做补偿,因为技能每次更新的间隔不稳定、其它客户端收到状态变化有延迟
锁定同步: 初始化帧: 所有战斗单位进入第一帧,随机种子保持一致,这样所有玩家的逻辑状态是完全一致的
         等待输入: 锁定同步算法会导致一人延迟卡住,其它人也跟着卡住
         同步输入: 每一帧的逻辑时间是固定的,所以输入一致,那么所有人的逻辑状态也是一致的
         战斗模拟: 需要实现一个与表现完全分离的战斗模拟器,服务器可以利用该模拟器进行模拟验证,客户端使用该模拟器同步逻辑状态
乐观同步: 初始化帧: 和锁定同步一样
         定时采集: 服务器定时采集所有客户端的输入(摇杆移动也是输入的移动指令,定时时间延迟是否会感觉到?)
         定时发送: 服务器同步每个定时间隔内的输入给所有客户端
         战斗模拟: 和锁定同步一样
         网络要求: 40ms以内应该是比较流畅
延迟补偿: 


