加密压缩
    MD5     生成16字节128位的数,每次处理512位64字节的数据,处理完后更新128位数据,不够64字节补1+0,最后生成128位MD5码
    UUID    MD5长度128位,UUID是128位数的16进制表示的字符串,格式08-04-04-04-0804
    HAFMAN  单个字符出现频率编码,由原始的不同的字符出现的次数为权值,构造哈夫曼树,每个字符有一条路径构成的编码
    LZ77    字典模型,首先有一个字典表,包含了出现过的单词或者句子,再次出现时只有一个位置索引即可
            滑动窗口,即字典,字典查找过程就是查找最大子串
    加密    基于异或运算的位加密算法,A^B=C C^B=A   RSA SHA
    BASE64  HTTP请求发送数据只能发送ASCII码,因此需要进行编码操作,编码后+号传输会变成空格
排序算法
    稳定排序 冒泡 插入 归并
    不稳定排序 快排 堆 选择
搜索算法
    正则表达式 ^匹配开头
               $匹配结尾
               *前面的字符出现>=0次
               +前面的字符出现>=1次
               .除了\n之外所有字符
               ?前面的字符出现0或1次
               \转义
               []多选一
               aAsdw
    A*启发式搜索
      f = g + h,open表存储待查子结点,close表存储已查子结点
    二分搜索  二叉搜索树、红黑树
动态规划
    状态方程 f(x) = f(x-1) + f(x-2)
数学算法
    轨迹方程
            平面:  Ax+By+Cz+D = 0
            直线:  两平面交点 起点+方向
            圆:    圆心+法线+半径
            斜抛:  分解为水平运动和垂直运动,计算出水平初始速度和垂直初始速度,vt-1/2gt^2 vt
            外心:  三角形外接圆圆心,垂直平分线交点
            内心:  三角形内接圆圆心,内角平分线交点
            重心:  三角形中线交点,满足定点到质心距离:质心到中点距离=2:1
    向量叉乘 axb = (a.yb.z - a.zb.y,a.zb.x - a.xb.z,a.xb.y - a.yb.x)
             如果是2D向量相乘,那么2D向量所在的两个分量结果一定为0,结果为三角形面积,法线长度
    射影定理 三角形垂线分割边为ADDB, 那么CD * CD = AD * DB
             AC = BC * cos∠BAC + AB * cos∠BCA; 
    线面夹角 范围是0-90
    海伦公式 三角形面积s^2 = p(p-a)(p-b)(p-c)
    质心坐标 线段AB和顶点P,如果P在AB上,那么顶点P的质心坐标为(u,v) P=uA+vB u+v=1
    定积分   
            ∫(a→b)f(x)dx  
            几何意义,x=a x=b x轴围成的图形的面积
    求和    
            Σ(m-n)xi      
            几何意义,xm到xn的和,用于密度计算
    偏导数   
            函数f(x,y) 在某一点在x方向的的导数记为 f'(x0,y0) = [f(x0+dx,y0) - f(x0,y0)]/dx(dx趋向于0)
            几何意义,对某个轴的导数表示线或者面上一点在这个点的对应轴的切线的斜率
            z=x^2+3xy+y^2在P(1,2)处的导数 
            f'(xp,yp)x=[(1+dx)^2+3(x+dx)y+y^2-f(xp,yp)]/dx=[dx^2+2dx+3dxy]/dx=dx+2x+3y=2x+3y
            f'(xp,yp)y=[x^2+3x(y+dy)+(y+dy)^2-f(xp,yp)]/dy=[3xdy+dy^2+2ydy]/dy=3x+dy+2y=3x+2y
    偏微分   df(x)/dx

    切线和法线
            切线和法线相互垂直,相乘结果为-1
            曲线的切线可以利用偏导数 求出各个轴向的偏导数之和乘以单位向量(x,y均为正向)结果就是法线
NGUI裁剪
    clipSoftness.xy,虚边界大小
    clipRange.xyzw,裁剪区域中心及大小
    shader内_clipRange = (-px/z,-py/w,1/z,1/w) clipArg = (z/sx,w/sy)
    前提条件,Panel在摄像机坐标系下没有偏移
    1.计算顶点坐标在Panel内到中心的距离(归一化为0到1的值),o.worldPos = (vx-px)/z,(vy-py)/w = o.vertex * _clipRange.zw + _clipRange.xy
      o.worldPos绝对值大于1则处于Panel外面,小于1在Panel内部
    2.计算顶点坐标在Panel内到边界的距离(归一化为0到1的值),o.distance = (z,w)-abs(vx-px,vy-py)
      该距离和虚边界大小比值可用于计算像素点alpha值 clamp(min(o.distance.xy/s.xy),0,1)
      算出最终表达式为 factor = [(z,w)-abs(vx-px,vy-py)]/(sx,sy)=[(1,1)-abs((vx-px)/z,(vy-py)/w)] * (z/sx,w/sy) = [(1,1) - abs(o.worldPos)] * clipArg;
      a = clamp(min(factor.x,factor.y),0,1)
    3.整理上述过程得出
      1.设置裁剪参数_clipRange=-px/z,-py/w,1/z,1/w) _clipArg=(z/sx,w/sy)
      2.顶点着色器内计算顶点坐标 o.worldPos = o.vertex * _clipRange.zw + _clipRange.xy
      3.像素着色器内计算alpha值 factor = [(1,1) - abs(o.worldPos)] * _clipArg; a = clamp(min(factor.x,factor.y),0,1)
    






