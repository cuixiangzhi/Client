实时阴影
    ShadowMap实时阴影
        原理:1.以实时灯光位置作为视点,渲染一张深度纹理
                生成过程: 
                    顶点shader计算深度
                        o.pos = UnityObjectToClipPos(v.vertex);
                        o.depth = o.pos.zw
                    像素shader记录深度(因为有差值)
                        float depth = o.depth.x / o.depth.y
                        fixed4 depth_color = EncodeFloatRGBA(depth)
             2.接受阴影的物体从模型空间转换到灯光空间,和深度图作比较,大于深度图中的深度则为阴影
                计算过程
                    顶点shader计算深度
                        objectToLightProj = mul(worldToLightProj,unity_ObjectToWorld);
                        o.proj = mul(objectToLightProj,v.vertex);
                        o.depth = o.proj.zw
                    像素shader比较深度
                        fixed4 depth_texture_color = tex2Dproj(_DepthTexture,o.proj);
                        float depth_texture = DecodeFloatRGBA(depth_texture_color);
                        float depth_current = o.depth.x / o.depth.y
                        if(depth_texture < depth_current) 阴影
    Projector实时投影
        原理:1.以实时灯光位置作为视点,渲染一张透明纹理
                生成过程:
                    顶点shader只计算坐标
                    像素shader直接返回不透明颜色
                    生成的纹理的alpha值大于0表示阴影,等于0表示不是阴影
             2.把纹理投影到场景内,类似于幻灯片投影到墙上一样
                计算过程:
                    顶点shader计算当前顶点的投影纹理齐次坐标
                        sproj = mul(_Projector,v.vertex);
                    像素shader采样然后插值计算alpha进行混合 Blend DstColor Zero 正片叠底
                        uv齐次 = UNITY_PROJ_COORD(sproj);
                        alpha = tex2DProj(_ShadowTex,uv齐次).a
                        uv = uv齐次.xy / uv齐次.w;
                        float2 factor = abs(uv4.xy / uv4.w - float2(0.5,0.5));
                        if(factor.x <= 0.5 && factor.y <= 0.5)
                        {
                            //首先把阴影的范围限制在投影纹理UV之内,然后计算UV和边界的距离插值处理渐变效果(用距离边界最小的值算)
                            float minFactorDis = 0.5 - max(factor.x,factor.y)
                            float dist = 1 - clamp((_ShadowGradient - minFactorDis),0,_ShadowGradient) / _ShadowGradient;
                            color *= (1 - _ShadowFactor * alpha * dist);
                        }
天空盒
    原理
        实时渲染中非常远的物体,大小几乎不会随着摄像机的移动而变化
        天空盒是一个由六个面的纹理构成的一个立方体即CubeMap,上下左右前后分别对应一张纹理
        摄像机始终处于立方体中心
        生成一个与远平面大小相同的MESH,渲染这个MESH时根据中心点指向顶点的向量计算出与CudeMap的交点,取出纹理像素值
        纹理映射
            第一步:根据最大维确定纹理图
            第二步:其它两个维度除以最大维度,缩放到[-1,1]
            第三步:把纹理坐标映射到[0,1]之内
    实现
        o.pos = mul(UNITY_MATRIX_MVP,v.vertex);
        o.pos.z = o.pos.w 让顶点始终处于远平面
        o.texcoord = o.pos.xyz
        color = texCUBE(_SKYTEX,o.texcoord)
水波纹效果
    原理:UV动画,屏幕每个像素的UV坐标以中心点为圆心,向圆外偏移,根据距离中心点的距离和偏移的时间计算偏移程度
    顶点shader: 
        普通的vertex变换和uv赋值
    像素shader:
        首先计算出圆心指向当前UV的向量(x方向乘以宽高比,确保波纹是圆形的) 
            dv = i.uv - fixed2(0.5,0.5) * (_ScreenParams.x/_ScreenParams.y,1)
            offset = |dv|
        然后计算波纹震动程度
            factor = a*sin(w)  
            a是振幅(偏移在0.05左右效果不错),a和offset相关时可以限制边界处幅度,例如a=(1-offset)*0.1
            w是震频(单位时间内的震动次数),w和时间相关,例如w=频率*(passedTime+offset*3)
        接着计算波纹波动范围
            波动的中心 center = moveSpeed*passedTime
            波动的范围 range
            波动的偏移 offsetFactor = clamp(range-abs(center-offset),0,1) / range,避免波动范围内的明显的边界
            波动的比例 factor = factor * offsetFactor
        最后计算扩散后的UV坐标 uv = uv + dv * factor
描边效果
    原理:使用两个Pass,一个渲染正面,一个渲染背面,背面的顶点沿着法线方向偏移一定距离
昼夜
透明
雾
水
云
草
树
角色
特效
