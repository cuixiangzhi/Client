光源类型
	平行光 点光源 聚光灯 环境光 面光源 反射球 发光球
光照分解
	自发光:物体本身在给定方向上辐射多少能量,它不会照亮其他物体,只是本身会变亮
	环境光:间接光,局部光照模型中用它来模拟间接反射的光
	漫反射:光线照射到物体表面,在各个方向反射多少能量,反射能量大小和入射角度有关,和观察角度无关
	高光:光线照射到物体表面,镜面反射出的能量,反射能量与反射方向和观察角度有关
光照模型
	局部光照和全局光照区别:
		都是模拟物体表面的光照物理现象的数学模型
		前者只考虑光源直接照射效果,不考虑反射和折射
	局部光照模型:
		原理:局部光照只考虑光源的直接照射效果,不考虑折射、次表面散射,也就是不考虑间接光
		Lambert光照模型：漫反射+环境光
			同等能量的光照射到的表面积越小,单位表面积收到的能量越多,反射光照的强度与表面法线和光源方向夹角的余弦值成正比
			反射光颜色=入射光颜色*漫反射系数*(法线与入射光线点乘)+环境光
			I=Ka*Ia+Kd*Id*dot(N,L)
		Phong光照模型：漫反射+环境光+高光
			通过反射光与视线的点积来影响高光,夹角越小,高光越强
			高光颜色=入射光颜色*高光反射系数*pow(max(0,视线与反射线点积),高光指数),高光指数越大,散射光越少,亮点越小
			显示出的模型像一个塑料
			I=Ka*Ia+Kd*Id*dot(N,L)+Ks*Is*pow(max(0,dot(V,R)),p) R+L=2dot(N,L)N R=2*dot(N,L)*N-L p越大光线越集中,亮点越小
		BlinnPhong光照模型:
			Phong模型的视线与反射线夹角不能大于90度,接近90度的地方就是高光的边缘,会出现迅速衰减
			BlinnPhong通过视线和入射线的夹角的平分线作为反射线来计算高光 平分线=lightDir+viewDir
			边缘地带高光有渐变效果
			I=Ka*Ia+Kd*Id*dot(N,L)+Ks*Is*pow(dot(N,H),p) N是入射光线和视线的半角向量
	全局光照模型
		原理:考虑直接光和间接光,例如半透明表面(发生折射)、次表面散射(进入子表面发生反射,例如皮肤)、表面渗色,全局光照更加柔和真实
			金属折射进入表面的光线会被吸收,非金属折射进入后会再次反射出来,BRDF公式用来模拟这种现象
			光照贴图只保留间接光,场景包含一个实时光,阴影会根据间接光处理虚实程度
		BRDF光照模型:
			BRDFDiffuse:
			BRDFSpecular
渲染路径
	LightMode
			在Lighting On的情况下,如果不设置,就会使用上一个对象使用过的光照模式
			vertex模式支持8个点光源,按照亮度排序,位置颜色信息存储在上述数组内
				MESH->VS(光照计算)->FS->FRAME_BUFFER
			Forward
				根据配置的逐像素光源个数,提取最亮的几个光源计算光照,其余的光源都以球谐函数
				MESH->VS->FS(光照计算)->FRAME_BUFFER
				ForwardBase: 
					#pragma multi_compile_fwdbase
					计算自发光、环境光、主平行光、光照贴图、阴影
				ForwardAdd:  
					Blend One One 
					#pragma multi_compile_fwdadd
					计算额外的逐像素光源,AddPASS会根据照亮该物体的光源数量被执行多次
					照亮每个物体的逐像素光源个数有限制,Unity会根据光源的类型及对物体的影响程度(距离、强度、类型等)进行排序
					_LightColor0和_WorldSpaceLightPos0存储当前逐像素光源的颜色和位置
			Deferred
				第一次渲染时不计算光照信息,只进行深度测试,通过了就把光照相关数据写入G-BUFFER(坐标、法线、UV、反射系数等等)
				第二次渲染遍历屏幕像素,针对有效的像素点读取G-BUFFER数据进行光照计算,更新颜色缓冲区
				MESH->VS->FS(无光)->MRT(深度、法线、颜色三个BUFFER存储光照所需信息)->FRAME_BUFFER
				延迟渲染不支持半透,阴影处理
			ShadowCaster
				渲染阴影映射纹理时调用该shader,没有会调用Fallback的对应shader,否则不产生阴影
光照计算
	位置&方向
		如果是平行光,那么方向是固定的,UNITY通过USING_DIRECTIONAL_LIGHT来区分是不是平行光
		#ifdef USING_DIRECTIONAL_LIGHT
			worldLightDir = normalize(_WorldSpaceLightPos0.xyz)
		#else
			worldLightDir = normalize(_WorldSpaceLightPos.xyz-i.worldPos.xyz)
		#endif
	颜色&强度
		_LightColor0是经过乘法计算后的颜色值
	衰减&阴影
		平行光衰减值为1
		非平行光需要公式计算衰减,UNITY把衰减值存储到了一张纹理内 
			_LightTexture0存储了每个点的衰减值
			首先计算光源空间下坐标
				lightSpacePos = mul(_LightMatrix0,i.worldPos).xyz
			然后根据距离平方采样得出衰减值
				atten = tex2D(_LightTexture0,dot(lightSpacePos,lightSpacePos).xx).UNITY_ATTEN_CHANNEL;
		计算阴影纹理坐标
			定义 SHADOW_COORDS(idx1) unityShadowCoord3 _ShadowCoord : TEXCOORD##idx1;
			计算 TRANSFER_SHADOW(a) a._ShadowCoord.xyz = mul(unity_ObjectToWorld, v.vertex).xyz - _LightPositionRange.xyz; 点光源
			读取 SHADOW_ATTENUATION(a) UnitySampleShadowmap(a._ShadowCoord); _ShadowMapTexture
		统一计算阴影*衰减
			UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos)
光照贴图
光线跟踪