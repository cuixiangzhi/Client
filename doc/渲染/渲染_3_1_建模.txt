表示
	二维物体
		直线段、折线、曲线段、多边形区域
	三维物体
		空间直线段、折线、曲线段、多边形、曲面片
	数据模型
		几何体的顶点信息罗列出来,以数据文件形式存在
		线框模型
			轮廓线的集合,没有表面信息,不适于真实感显示
		表面模型
			由面构成的,每个面由N个顶点定义
		实体模型
	建模方法
		软件建模,美术手工制作
		设备建模,3D扫描仪扫描三维物体建模,3个方向探针检测?
		图像建模,IBMR技术通过二维图像技术恢复场景的三维几何结构 计算机视觉
引擎模型
	MeshFilter
		mesh当前模型的mesh信息,读取后会导致mesh内存翻倍,因为是一个单独的实例
		sharedMesh当前模型共享的mesh信息,引用传递
	Mesh
		isReadable:打开时会同时在内存和显存里保持两份mesh内存,运行时不读取尽量不打开,节省内存
		vertices数组定义了所有的顶点信息
		triangles定义每个三角面的三个顶点的顶点数组下标,长度为3的整数倍
		normals定义了每个顶点的法线信息
		colors数组定义了每个顶点的颜色信息
		uv..uv8定义了每个顶点的uv坐标,最多支持一张主贴图,8张子贴图
		合并MESH算法
			意义:
	MeshRender
传输顶点
	单个传输 glBegin glEnd之间通过glVertex*一个一个的设置
			 效率贼低
			 OpenGL3.0 已废弃
	显示列表 提前设置好顶点信息,传给GPU之后无法修改
			 应用: 矩阵操作 材质定义 纹理定义 光照定义
			 创建显示列表 GLuint id = glGenLists(1);
			 			  glNewList(id,GL_COMPILE);
			 			  glEndList();
			 绘制显示列表 glCallList(id);
			 删除显示列表 glDeleteLists(id,1);
	顶点数组 提前设置好顶点信息,传给GPU之后可以修改
			 顶点数据在内存中,每次绘制时都需要传输给GPU
			 启用/禁用数组 glEnableClientState() glDisableClientState()
			 指定数组位置 glVertexPointer glNormalPointer glColorPointer glIndexPointer glTexCoordPointer 
			 传输顶点数组 glDrawArrays(GL_TRIANGLES, 0, 36)  直接绘制顶点数组
			 			  glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_BYTE, ptr); 绘制索引数组
	以上三种方式均已过时
	VBO     顶点数组的升级版本,在显存内申请一块内存,存储顶点相关信息
			可以通过一些API修改这个数据
			创建显存对象 Gluint vboID;glGenBuffers(1,&vboID);
			绑定对象类型 glBindBuffer(GL_ARRAY_BUFFER,vboID);
						GL_ELEMENT_ARRAY_BUFFER 索引缓冲VBO
						GL_ARRAY_BUFFER 顶点缓冲VBO
			设置对象属性  glBufferData(GL_ARRAY_BUFFER,数组内存大小,数组指针,存储方式); 
					    glBufferSubData(GL_ARRAY_BUFFER,对象偏移,数组长度,数组指针);
						static  一次指定多次使用,适用于静态物体
						dynamic 反复指定反复使用,适用于动态物体
						stream  一次指定一次使用,每帧都会变化
						draw 表示对象被用来绘制使用
						read 表示对象被用来读取使用
						copy
			绘制缓存数据  
						开启attrib
						gl*AttribPointer  定义VBO顶点、颜色、法线、UV格式
						glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_BYTE, 0); 绘制索引VBO
						关闭attrib
			映射显存对象
						 void* glMapBuffer(GL_ARRAY_BUFFER,GL_READ_WRITE);可以映射显存	  
						 glUnmapBuffer(GL_ARRAY_BUFFER)取消映射 
			删除缓存数组 glDeleteBuffers(vboID);
	VAO
			存储了VBO的引用和顶点属性格式,VAO本身不存储顶点数据
			绑定VAO之后 后续创建的VBO都属于当前VAO
			创建VAO glGenVertexArray()
			绑定VAO glBindVertexArray()
			使用VAO之后,后续创建的VBO EBO只需要bindvao就可以绘制了
	静态合批
		创建一个大的VBO存储顶点,不同的IBO存储索引,每次绘制只绘制单个IBO(索引大的VBO上的一段)
		静态合批的对象是共享相同材质球的
	动态合批
		CPU动态检测相同材质的MESH,合并成一个VBO,合并有顶点数限制
	vertex constant instancing
		对于模型一致的物体,只提交原始模型给GPU,其他属性单独构成BUFFER提交给GPU
	GPU INSTANCE
		大量物体只提交一个原始模型给GPU,其他属性交给SHADER来处理
		drawmesh(instanced) 代表被GPU INSTANCE
		unity默认只对相同MESH相同材质 不同位置、缩放、旋转的物体进行GPU INSTANCE
			受不同实时灯光或者处于不同光照贴图的也不会被合批
		其他属性需要自己在shader内添加
			C#  
				创建实例变量
				MaterialPropertyBlock
			shader
				标记编译生成实例变量
				#pragma multi_compile_instancing 
				定义实例ID
				UNITY_VERTEX_INPUT_INSTANCE_ID   
				UNITY_SETUP_INSTANCE_ID
				UNITY_TRANSFER_INSTANCE_ID
				定义实例变量
		       	UNITY_INSTANCING_BUFFER_START(Props)
	           		UNITY_DEFINE_INSTANCED_PROP(fixed4, _Color)
	        	UNITY_INSTANCING_BUFFER_END(Props)
	        	获取实例变量
	        	UNITY_ACCESS_INSTANCED_PROP(Props, _Color)