#! python2
#coding:utf-8
import traceback
import os
import time
import sys
import xlrd
import codecs
import xml.etree.ElementTree as ET

def convert_to_unicode(data):
    if(not (type(data) is unicode)):
        return unicode(data)
    else:
        return data

def make_str_table(sheet):
    _keys =[]
    _idxs=[]
    _vals=[]
    #读取第一行,提取字段,字段所在列,字段类型
    index = -1
    for colValue in sheet.row_values(3):
        index += 1
        ctype = sheet.cell(3,index)
        if(ctype == 0 or (ctype == 1 and colValue == "")):
            continue
        _keys.append(colValue)
        _idxs.append(index)
    
    #从第三行开始遍历excel表,提取数据,没有主键不导出数据
    for i in range(6,sheet.nrows):
        index = -1
        for idx in _idxs:
            index += 1
            value = convert_to_unicode(sheet.cell_value(i,idx))
            if(len(value) >= 3 and value[-2:] == ".0"):
                value = value[:-2]
            _vals.append(value)
    
    #返回table,key由有效字段构成
    #val由每行的有效数据构成,与key对应
    table=[sys.argv[3],_keys,_vals]
    return table

#提取excel每个sheet,构造表数组
def make_str_table_list(tablePath):
    table_list = []
    #检查参数,打开文件  
    tablePath = os.path.abspath(tablePath)
    excel = xlrd.open_workbook(tablePath)
    #遍历子表,构造table
    for sheet_name in excel.sheet_names():
        #检测表名,是否符合规范,不符合则跳过
        if(sheet_name[-1] != "="):
            continue
        #构造表数据,并加入列表内
        sheet = excel.sheet_by_name(sheet_name)
        table = make_str_table(sheet)
        table_list.append(table)    
    return table_list

#导出lua配置文件
def export_lua_config(tableName,keys,vals,exportPath):
    if(exportPath == ""):
        return
    exportPath = os.path.abspath(exportPath)
    fileObj = codecs.open(exportPath + "/" + tableName + ".lua","wb","utf-8")
    fileObj.write("--this file is generated by export tools,don't edit!\n\n")
    fileObj.write("module(...,package.seeall)\n\n")
    fileObj.write("require " + "\"" + tableName + "_pb\"\n")
    for i in range(0,len(vals),len(keys)):
        if(str(vals[i]) == "" or str(vals[i + 1]) == ""):
            continue
        fileObj.write(vals[i + 1])
        fileObj.write("=")
        fileObj.write(str(vals[i]))
        fileObj.write("\n")
        
    fileObj.write("\n\n")
    fileObj.write("local data = nil\n")
    pbName = tableName + "_pb"
    datasName = "All" + tableName
    dataName = tableName
    
    fileObj.write("function Init()\n")
    fileObj.write("\tGameCore.AssistLoader.AsynReadBytesByName(\"" + tableName +".bytes\", OnLoadData, 1, false, true);\n")
    fileObj.write("end\n")
    
    fileObj.write("function OnLoadData(bytes,param)\n")
    fileObj.write("\tlocal datas = " + pbName + "." + datasName + "()\n")
    fileObj.write("\tdatas:ParseFromString(bytes)\n")
    fileObj.write("\tdata = {}\n")
    fileObj.write("\tfor _,v in pairs(datas.tlist) do\n")
    fileObj.write("\t\tif v.key and v.key > 0 then\n")
    fileObj.write("\t\t\tdata[v.key] = v;\n")
    fileObj.write("\t\tend\n")
    fileObj.write("\tend\n")
    fileObj.write("end\n")
    
    fileObj.write("function GetData(key)\n")
    fileObj.write("\treturn data[key];\n")
    fileObj.write("end\n")
    
    fileObj.write("function GetStringValue(key)\n")
    fileObj.write("\treturn data[key].stringValue;\n")
    fileObj.write("end\n")
    
    fileObj.write("function GetIntValue(key)\n")
    fileObj.write("\treturn data[key].intValue;\n")
    fileObj.write("end\n")
    
    fileObj.write("function GetFloatValue(key)\n")
    fileObj.write("\treturn data[key].intValue / 10000;\n")
    fileObj.write("end\n")
    fileObj.close()
    return
    
#导出XML
def export_xml():
    xlrd.Book.encoding = "gbk"
    tablePath = os.path.abspath(sys.argv[2])
    xmlPath = os.path.abspath(sys.argv[3])
    config = sys.argv[4].split(';')
    excel = xlrd.open_workbook(tablePath)
    #遍历子表,导出XML
    for sheet_name in excel.sheet_names():
        #检测表名,是否符合规范,不符合则跳过
        if(sheet_name[-1] != "="):
            continue
        #打开一个表单
        sheet = excel.sheet_by_name(sheet_name)
        _cfg = []
        for i in range(0,len(config)):
            if(len(_cfg) > 0 and _cfg[0] == sheet_name[:-1].encode("gbk")):
                break
            _cfg = config[i].split(',')
        _tbCount = int((len(_cfg) - 1) / 3)
        
        print(u"正在导出:" + sheet_name[:-1])
        print(u"子表个数:" + str(_tbCount))
        #第三行开始是字段
        #第七行开始是数据
        #导出每个子表
        for i in range(0,_tbCount):
            tableName = _cfg[1 + i * 3]
            startCol = int(_cfg[1 + i * 3 + 1])
            endCol = int(_cfg[1 + i * 3 + 2])
            print(u"导出子表:" + tableName)
            fileObj = codecs.open(xmlPath + "/" + tableName + ".xml","wb","utf-8")
            fileObj.write("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n")
            fileObj.write("<" + tableName + "s xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n")
            #每个子表每行数据
            for i in range(6,sheet.nrows):
                if(sheet.cell(i,0).ctype == 0):
                    continue
                firstKey = sheet.cell_value(3,0)
                firstValue = convert_to_unicode(sheet.cell_value(i,0))
                if(len(firstValue) >= 3 and firstValue[-2:] == ".0"):
                    firstValue = firstValue[:-2]
                    
                fileObj.write("\t<" + tableName + ">\n")        
                fileObj.write("\t\t<" + firstKey + ">")     
                fileObj.write(firstValue)
                fileObj.write("</" + firstKey + ">\n")  
                
                for j in range(startCol - 1,endCol):                    
                    keyType = sheet.cell(3,j).ctype
                    valueType = sheet.cell(i,j).ctype
                    if(keyType != 0 and valueType != 0):
                        key = sheet.cell_value(3,j)
                        value = convert_to_unicode(sheet.cell_value(i,j))
                        fileObj.write("\t\t<" + key + ">")                      
                        if(len(value) >= 3 and value[-2:] == ".0"):
                            value = value[:-2]
                        fileObj.write(value)
                        fileObj.write("</" + key + ">\n")
                fileObj.write("\t</" + tableName + ">\n")
            fileObj.write("</" + tableName + "s>")
            fileObj.close()
    return
    
#合并XML
def merge_xml():
    xmlPath = os.path.abspath(sys.argv[2])
    for merge in sys.argv[3].split(";"):
        merge_tables = merge.split(",")
        targetName = merge_tables[0]
        print(u"合并XML 目标文件:" + targetName + u" 子表个数:" + str(len(merge_tables) - 1))
        file1 = codecs.open(xmlPath + "/" + targetName + ".xml","wb","utf-8")
        file1.write("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n")
        file1.write("<" + targetName + "s xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n")
        for i in range(1,len(merge_tables)):
            curName = merge_tables[i]
            curFilePath = xmlPath + "/" + curName + ".xml"
            file2 = codecs.open(curFilePath,"rb","utf-8")   
            for line in file2:
                if(line[0] == "\t" or line[0] != '<'):
                    file1.write(line.replace(curName + ">",targetName + ">"))
            file2.close()
        file1.write("</" + targetName + "s>")
        file1.close()
    return

#导出bytes
def export_bytes():
    xmlPath = os.path.abspath(sys.argv[2]).replace("\\","/")
    bytesPath = os.path.abspath(sys.argv[3]).replace("\\","/").decode("gbk")
    for data in sys.argv[4].split(";"):
        xmlName = data.split(",")[0]
        tmpPath = os.path.abspath(sys.path[0] + "/export/" + xmlName + ".py").replace("\\","/")
        moduleName = data.split(",")[1].split(".")[0] + "_pb2"
        className = data.split(",")[1].split(".")[1]
        fieldName = data.split(",")[1].split(".")[2]
        #创建导出bytes的py文件
        fileObj = codecs.open(tmpPath,"wb","utf-8")    
        fileObj.write("#coding:utf-8\n")
        fileObj.write("import os\n")
        fileObj.write("import " + moduleName + "\n\n")
        #变量转换
        fileObj.write("def convert(field,value):\n")
        fileObj.write("\tif(type(field) is bool):\n\t\treturn value == \"1\" or value.lower() == \"true\"\n")
        fileObj.write("\tif(type(field) is int and value.find(\".\") == -1):\n\t\treturn int(value)\n")
        fileObj.write("\tif(type(field) is int and value.find(\".\") != -1):\n\t\treturn float(value)\n")
        fileObj.write("\tif(type(field) is float):\n\t\treturn float(value)\n")
        fileObj.write("\tif(type(field) is str or type(field) is unicode):\n\t\treturn value\n")
        #导入PROTO模块      
        fileObj.write("NEWDATA = " + moduleName + "." + className + "()\n")
        fileObj.write("BYTES_PATH = u\"" + bytesPath + "/" + xmlName + ".bytes\"\n")
        #打开XML,遍历子结点
        tree = ET.parse(xmlPath + "/" + xmlName + ".xml")
        root = tree.getroot()
        for child in root:
            fileObj.write("data = NEWDATA." + fieldName + ".add()\n")
            for field in child:
                if(field.tag.find("-") != -1):
                    #字段全名
                    fieldTagNames = field.tag.split('-')
                    fieldTagName = fieldTagNames[0]
                    for i in range(1,len(fieldTagNames)):
                        if(fieldTagNames[i].find(".") != -1):
                            fieldTagName = fieldTagName + "[" + fieldTagNames[i].replace(".","].",1)
                        else:
                            fieldTagName = fieldTagName + fieldTagNames[i] + "]"
                    #数组创建
                    fieldNameSlice = fieldTagName.split(".")
                    fieldFullName = ""
                    for i in range(0,len(fieldNameSlice)):
                        if(fieldNameSlice[i].find("]") != -1):
                            fieldNameSliceField = fieldNameSlice[i].split("[")[0]
                            fieldNameSliceIndex = int(fieldNameSlice[i].split("[")[1].split("]")[0])
                            if(fieldFullName == ""):
                                fieldFullName = fieldNameSliceField
                            else:
                                fieldFullName = fieldFullName + "." + fieldNameSliceField
                            fileObj.write("if(len(data." + fieldFullName + ") <= " + str(fieldNameSliceIndex) + "):\n")
                            fileObj.write("\tif(hasattr(data." + fieldFullName +",\"add\")):\n")
                            fileObj.write("\t\tdata." + fieldFullName + ".add()\n")
                            fileObj.write("\telse:\n")
                            fileObj.write("\t\tdata." + fieldFullName + ".append(0)\n")
                            fieldFullName = fieldFullName + "[" + str(fieldNameSliceIndex) + "]"
                        else:
                            if(fieldFullName == ""):
                                fieldFullName = fieldNameSlice[i]
                            else:
                                fieldFullName = fieldFullName + "." + fieldNameSlice[i]
                    fileObj.write("data." + fieldTagName + "=convert(data." + fieldTagName + ",u\"" + field.text + "\")\n")
                else:
                    fileObj.write("data." + field.tag + "=convert(data." + field.tag + ",u\"" + field.text + "\")\n")
        #导出二进制
        fileObj.write("bytes = NEWDATA.SerializeToString()\n")
        fileObj.write("NEWFILE = open(BYTES_PATH,\"wb\")\n")
        fileObj.write("NEWFILE.write(bytes)\n")
        fileObj.write("NEWFILE.close()\n")
        fileObj.close()
        #执行
        os.system(tmpPath)
    return
    
#导出代码配置文件
def export_config():
    #导出流程介绍
    #table[]内容 name,keys,types,values
    str_tables = make_str_table_list(sys.argv[2])
    for table in str_tables:
        export_lua_config(table[0],table[1],table[2],sys.argv[4])
        
if __name__ == "__main__":   
    try:
        print(u"导出开始")
        if(sys.argv[1] == "1" and len(sys.argv) >= 5):          
            export_xml()
        elif(sys.argv[1] == "2" and len(sys.argv) >= 4):
            merge_xml()
        elif(sys.argv[1] == "3" and len(sys.argv) >= 5):
            export_bytes()
        elif(sys.argv[1] == "4" and len(sys.argv) >= 5):
            export_config()
        print(u"导出成功")
    except:
        print(u"导出失败")
        traceback.print_exc()
        os.system("pause")